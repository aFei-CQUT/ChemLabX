目录结构:
|-- 文件: .gitattributes
|-- 文件: .gitignore
|-- 文件夹: csv_data
|   |-- 文件夹: 传热
|   |   |-- 文件夹: 传热原始数据记录表(非)
|   |   |   |-- 文件: 原始数据_无强化套管.csv
|   |   |   |-- 文件: 原始数据_有强化套管.csv
|   |   |   |-- 文件: 数据预处理_无强化套管.csv
|   |   |   |-- 文件: 数据预处理_有强化套管.csv
|   |   |-- 文件夹: 传热原始数据记录表[空]
|   |   |   |-- 文件: 原始数据.csv
|   |   |   |-- 文件: 数据预处理结果.csv
|   |-- 文件夹: 干燥
|   |   |-- 文件夹: 干燥原始数据记录表(非)
|   |   |   |-- 文件: 原始数据1.csv
|   |   |   |-- 文件: 原始数据2.csv
|   |   |   |-- 文件: 数据预处理.csv
|   |   |-- 文件夹: 干燥原始数据记录表[空]
|   |   |   |-- 文件: 原始数据1.csv
|   |   |   |-- 文件: 原始数据2.csv
|   |   |   |-- 文件: 数据预处理.csv
|   |-- 文件夹: 流体
|   |   |-- 文件夹: 流体原始数据记录表(非)
|   |   |   |-- 文件: 流体阻力原始数据.csv
|   |   |   |-- 文件: 离心泵原始数据.csv
|   |   |-- 文件夹: 流体原始数据记录表[空]
|   |   |   |-- 文件: 流体阻力原始数据.csv
|   |   |   |-- 文件: 离心泵原始数据.csv
|   |-- 文件夹: 精馏
|   |   |-- 文件夹: 精馏原始记录表(非)
|   |   |   |-- 文件: Sheet1.csv
|   |   |-- 文件夹: 精馏原始记录表[空]
|   |   |   |-- 文件: Sheet1.csv
|   |-- 文件夹: 萃取
|   |   |-- 文件夹: 萃取原始数据记录表(非)
|   |   |   |-- 文件: 1_原始数据记录.csv
|   |   |   |-- 文件: 2_数据预处理.csv
|   |   |   |-- 文件: 3_分配曲线数据集.csv
|   |   |   |-- 文件: 5_图解积分数据集.csv
|   |   |   |-- 文件: 6_图解积分图.csv
|   |   |   |-- 文件: 7_结果整合.csv
|   |   |-- 文件夹: 萃取原始数据记录表[空]
|   |   |   |-- 文件: 1_原始数据记录.csv
|   |   |   |-- 文件: 2_数据预处理.csv
|   |   |   |-- 文件: 3_分配曲线数据集.csv
|   |   |   |-- 文件: 5_图解积分数据集.csv
|   |-- 文件夹: 解吸
|   |   |-- 文件夹: 解吸原始记录表(非)
|   |   |   |-- 文件: 干填料.csv
|   |   |   |-- 文件: 水流量一定_空气流量改变.csv
|   |   |   |-- 文件: 湿填料.csv
|   |   |   |-- 文件: 空气流量一定_水流量改变.csv
|   |   |-- 文件夹: 解吸原始记录表[空]
|   |   |   |-- 文件: 干填料.csv
|   |   |   |-- 文件: 水流量一定_空气流量改变.csv
|   |   |   |-- 文件: 湿填料.csv
|   |   |   |-- 文件: 空气流量一定_水流量改变.csv
|   |-- 文件夹: 过滤
|   |   |-- 文件夹: 过滤原始数据记录表(非)
|   |   |   |-- 文件: Sheet1.csv
|   |   |-- 文件夹: 过滤原始数据记录表[空]
|   |   |   |-- 文件: Sheet1.csv
|-- 文件夹: gui
|   |-- 文件: app.py
|   |-- 文件夹: screens
|   |   |-- 文件夹: calculators
|   |   |   |-- 文件: distillation_calculator.py
|   |   |   |-- 文件: drying_calculator.py
|   |   |   |-- 文件: extraction_calculator.py
|   |   |   |-- 文件: filteration_calculator.py
|   |   |   |-- 文件: fluid_flow_calculator.py
|   |   |   |-- 文件: heat_transfer_calculator.py
|   |   |   |-- 文件: oxygen_desorption_calculator.py
|   |   |   |-- 文件: __init__.py
|   |   |-- 文件夹: common_screens
|   |   |   |-- 文件: base_screen.py
|   |   |   |-- 文件: data_record_screen.py
|   |   |   |-- 文件: __init__.py
|   |   |-- 文件夹: common_widgets
|   |   |   |-- 文件: plot_widget.py
|   |   |   |-- 文件: spin_entries_widget.py
|   |   |   |-- 文件: string_entries_widget.py
|   |   |   |-- 文件: table_widget.py
|   |   |   |-- 文件: text_widget.py
|   |   |   |-- 文件: __init__.py
|   |   |-- 文件: distillation_screen.py
|   |   |-- 文件: drying_screen.py
|   |   |-- 文件: extraction_screen.py
|   |   |-- 文件: filteration_screen.py
|   |   |-- 文件: fluid_flow_screen.py
|   |   |-- 文件: heat_transfer_screen.py
|   |   |-- 文件夹: maths
|   |   |   |-- 文件: common_maths.py
|   |   |   |-- 文件: __init__.py
|   |   |-- 文件: oxygen_desorption_screen.py
|   |   |-- 文件夹: plotters
|   |   |   |-- 文件: distillation_plotter.py
|   |   |   |-- 文件: drying_plotter.py
|   |   |   |-- 文件: extraction_plotter.py
|   |   |   |-- 文件: filteration_plotter.py
|   |   |   |-- 文件: fluid_flow_plotter.py
|   |   |   |-- 文件: heat_transfer_plotter.py
|   |   |   |-- 文件: oxygen_desorption_plotter.py
|   |   |   |-- 文件: __init__.py
|   |   |-- 文件夹: processors
|   |   |   |-- 文件: distillation_experiment_processor.py
|   |   |   |-- 文件: drying_experiment_processor.py
|   |   |   |-- 文件: extraction_expriment_processor.py
|   |   |   |-- 文件: filteration_experiment_processor.py
|   |   |   |-- 文件: fluid_flow_experiment_processor.py
|   |   |   |-- 文件: heat_transfer_experiment_processor.py
|   |   |   |-- 文件: oxygen_desorption_experiment_processor.py
|   |   |   |-- 文件: __init__.py
|   |   |-- 文件夹: utils
|   |   |   |-- 文件: config.py
|   |   |   |-- 文件: expserial.py
|   |   |   |-- 文件: __init__.py
|   |   |-- 文件夹: widgets
|   |   |   |-- 文件: __init__.py
|   |   |-- 文件: __init__.py
|   |-- 文件: __init__.py
|-- 文件: LICENSE
|-- 文件夹: logos
|   |-- 文件: ce.icns
|   |-- 文件: ce.ico
|   |-- 文件: ce.png
|-- 文件: main.py
|-- 文件夹: manual
|   |-- (空目录)
|-- 文件: README.md
|-- 文件: requirements.txt
|-- 文件: __init__.py


================================================================================
E:\Chem-Experiment-Process-App\.gitignore 的内容:
================================================================================
*.png
*.zip
*.xlsx
*.pyc

================================================================================
E:\Chem-Experiment-Process-App\main.py 的内容:
================================================================================
# Author: 刘抗非
# 本软件参考 北京大学-物理化学溶解燃烧热中级实验项目（Author：赵泽华） 的设计进行架构的设计
# 该软件为非盈利软件，若分发请参考 LICENSE 文件

"""
快速启动:
    运行"main-win.exe"或"main-mac.app"即可自动运行main.py
    如出现异常情况，尝试运行"requirements-win.exe"或"requirements-mac.app"安装或更新依赖库
    main-win/mac需要与main.py在同一目录下，requirements-win/mac需要与requirements.txt在同一目录下

可调参数:
    dx: 积分、绘图步长
    time_interval: 记录数据间隔，单位毫秒
    plot_max_points: 绘图最大点数
    port_timeout: 串口超时时间，单位秒
    std_limit: 自动寻找平台期的标准差阈值
    time_lower_limit: 自动寻找平台期的最小时间窗口
    time_upper_limit: 自动寻找平台期的最大时间窗口
    width_height_inches: 保存图片尺寸，单位英尺
    dpi: 保存图片DPI

内置库:
    csv
    os
    re
    sys
    shutil
    time
    tkinter
"""

# 内置库
import sys
import os
import shutil

# 动态获取路径
current_script_path = os.path.abspath(__file__)
project_root = os.path.dirname(os.path.dirname(current_script_path))
sys.path.insert(0, project_root)

# 自建库
from gui.app import App

# 可调参数
dx = 0.1  # 积分、绘图步长
time_interval = 500  # 记录数据间隔，单位毫秒
plot_max_points = 500  # 绘图最大点数
port_timeout = 0.25  # 串口超时时间，单位秒
std_limit = 0.005  # 自动寻找平台期的标准差阈值
time_lower_limit = 30  # 自动寻找平台期的最小时间窗口
time_upper_limit = 40  # 自动寻找平台期的最大时间窗口
width_height_inches = (10, 6)  # 保存图片尺寸，单位英尺
dpi = 600  # 保存图片DPI

if __name__ == "__main__":
    # 获取当前路径
    # 如果是pyinstaller打包的exe文件，则获取可执行文件所在目录的绝对路径
    if getattr(sys, "frozen", False):
        py_path = os.path.dirname(os.path.abspath(sys.executable))
        # 如果是mac
        if sys.platform == "darwin":
            for i in range(3):
                py_path = os.path.dirname(py_path)
    # 如果是运行的py文件，则获取py文件所在目录的绝对路径
    else:
        py_path = os.path.dirname(os.path.abspath(__file__))
    App(
        dx,
        time_interval,
        plot_max_points,
        port_timeout,
        std_limit,
        time_lower_limit,
        time_upper_limit,
        width_height_inches,
        dpi,
        py_path,
    )
    # 清除缓存文件夹
    pycache_dir = py_path + "/__pycache__"
    if os.path.exists(pycache_dir):
        shutil.rmtree(pycache_dir)


================================================================================
E:\Chem-Experiment-Process-App\README.md 的内容:
================================================================================
# Chem-Filter 🧪

**重庆理工大学化学化工学院化工实验设计大赛参赛项目**

## 项目简介

Chem-Filter 是一个实验数据处理与可视化的工具，专为化学实验中的数据分析而设计。该工具通过图形化界面，支持导入数据、数据处理、异常值检测及拟合分析，最终输出处理结果并生成图表，以帮助实验人员更加高效地进行实验数据分析。

## 功能概述

- **数据加载与处理**：支持从 CSV 文件中导入实验数据，进行数据清洗、标准化处理。
- **异常值检测**：自动检测并排除数据中的异常值，以提高拟合结果的准确性。
- **数据拟合**：支持线性拟合，并提供拟合结果的斜率、截距等信息。
- **图表生成与展示**：生成包含数据拟合曲线、异常值检测图、数据分布等的各类图表。
- **结果压缩与导出**：将生成的图表和数据结果压缩成 ZIP 文件，便于分发和存储。

## 技术栈

- **Python**：主要编程语言
- **Tkinter**：用于构建图形界面
- **Matplotlib**：用于绘制图表和可视化数据
- **Pandas**：用于处理实验数据
- **NumPy**：用于科学计算
- **Scikit-learn**：用于数据拟合和异常值检测

## 安装指南

### 环境准备

1. 安装 Python 3.9 或更高版本。
2. 安装所需的依赖库：

```bash
pip install -r requirements.txt
```

### 运行项目

1. 将项目克隆到本地：

```bash
git clone https://github.com/your-username/Chem-Filter.git
```

2. 进入项目目录并运行主程序：

```bash
python main.py
```

3. 打开 GUI 界面后，选择需要分析的 CSV 数据文件，进行数据处理、拟合及图表生成。

## 使用说明

1. **导入数据**：点击“导入数据”按钮，选择需要分析的 CSV 文件。支持的数据格式为标准的 CSV 文件。
2. **处理数据**：点击“处理数据”按钮，系统会自动对数据进行清洗、拟合，并检测异常值。
3. **绘制图形**：处理完数据后，点击“绘制图形”按钮，生成数据拟合曲线和异常值检测图。
4. **导出结果**：所有结果图表会保存在项目文件夹的“拟合图结果”中，并自动压缩成 ZIP 文件，便于分享和存档。

## 项目结构

```
目录结构:
|-- 文件: .gitattributes
|-- 文件: .gitignore
|-- 文件夹: .vscode
|   |-- (空目录)
|-- 文件夹: gui
|   |-- 文件: app.py
|   |-- 文件夹: logos
|   |   |-- 文件: chem.icns
|   |   |-- 文件: chem.ico
|   |   |-- 文件: chem.png
|   |-- 文件夹: screens
|   |   |-- 文件夹: common_screens
|   |   |   |-- 文件: base_record_data_screen.py
|   |   |   |-- 文件: __init__.py
|   |   |-- 文件: filteration_calculator.py
|   |   |-- 文件: filteration_experiment_processor.py
|   |   |-- 文件: filteration_plotter.py
|   |   |-- 文件: filteration_screen.py
|   |   |-- 文件: __init__.py
|   |-- 文件夹: utils
|   |   |-- 文件: config.py
|   |   |-- 文件: expserial.py
|   |   |-- 文件夹: funcs
|   |   |   |-- 文件: dct2cols.py
|   |   |   |-- 文件: file_name_extension.py
|   |   |   |-- 文件: __init__.py
|   |   |-- 文件夹: maths
|   |   |   |-- 文件: common_maths.py
|   |   |   |-- 文件: maths_filteration.py
|   |   |   |-- 文件: __init__.py
|   |   |-- 文件: __init__.py
|   |-- 文件夹: widgets
|   |   |-- 文件夹: common_widgets
|   |   |   |-- 文件: plot_widget.py
|   |   |   |-- 文件: spin_entries_widget.py
|   |   |   |-- 文件: string_entries_widget.py
|   |   |   |-- 文件: table_widget.py
|   |   |   |-- 文件: text_widget.py
|   |   |   |-- 文件: __init__.py
|   |   |-- 文件: filteration_spin_entries_widget.py
|   |   |-- 文件: __init__.py
|   |-- 文件: __init__.py
|-- 文件: LICENSE
|-- 文件: main.py
|-- 文件夹: manual
|   |-- (空目录)
|-- 文件: README.md
|-- 文件: requirements.txt
|-- 文件: __init__.py
|-- 文件夹: 拟合图结果
|   |-- 文件: 1.png
|   |-- 文件: 2.png
|   |-- 文件: 3.png
|   |-- 文件: 4.png
|   |-- 文件: 5.png
|   |-- 文件: 6.png
|   |-- 文件: 7.png
|   |-- 文件: 8.png
|   |-- 文件: 拟合图整合图.png
|-- 文件: 拟合图结果.zip
|-- 文件: 过滤原始数据记录表(非).csv
```

## 开发者

- **项目负责人**：刘抗非
- **开发人员**：刘抗非

## License

该项目遵循 GNU 许可证，详情请见 [LICENSE](LICENSE) 文件。

## 鸣谢

本项目是受到 [北京大学-化学与分子工程学院-中级物理化学实验项目](https://github.com/Zhao-Zehua/Dissolution-Combustion) 的启发，参考其中的逻辑重新设计结构后编写的。在此要特别鸣谢[Zehua Zhao同学](https://github.com/Zhao-Zehua)。


================================================================================
E:\Chem-Experiment-Process-App\requirements.txt 的内容:
================================================================================
# === python版本 ===
# python = 3.9.21

# === 第三方核心科学计算库 ===
numpy
pandas
matplotlib
scikit-learn

# === 数据处理与文件操作 ===
openpyxl                    # 处理 Excel 文件
opencv-python               # OpenCV 图像处理

# === GUI 相关依赖 ===
ttkbootstrap                # 第三方主题库（确保名称正确，PyPI 上的包名为 ttkthemes）

# === 标准库（无需安装，仅作说明） ===
# logging       --> Python 内置
# tkinter       --> Python 内置

================================================================================
E:\Chem-Experiment-Process-App\__init__.py 的内容:
================================================================================


================================================================================
E:\Chem-Experiment-Process-App\gui\app.py 的内容:
================================================================================
# app.py

# 导入标准库结果
import logging
import traceback
import sys
import os

# 动态获取项目根路径
current_script_path = os.path.abspath(__file__)
project_root = os.path.dirname(os.path.dirname(current_script_path))
sys.path.insert(0, project_root)

# 导入外部库
import ttkbootstrap as ttk
from tkinter import PhotoImage

# 导入屏幕类
from gui.screens.filteration_screen import Filteration_Screen
from gui.screens.heat_transfer_screen import Heat_Transfer_Screen
from gui.screens.extraction_screen import Extraction_Screen
from gui.screens.drying_screen import Drying_Screen
from gui.screens.oxygen_desorption_screen import Oxygen_Desorption_Screen
from gui.screens.distillation_screen import Distillation_Screen
from gui.screens.fluid_flow_screen import Fluid_Flow_Screen

# 导入配置
from gui.screens.utils.config import *

# 配置日志记录
logging.basicConfig(level=logging.DEBUG, format="%(asctime)s - %(levelname)s - %(message)s")


class App:
    """
    应用主体
    """

    def __init__(
        self,
        dx: float = 0.1,
        time_interval: int = 500,
        plot_max_points: int = 500,
        port_timeout: float = 0.25,
        std_limit: float = 0.005,
        time_lower_limit: int = 30,
        time_upper_limit: int = 40,
        width_height_inches: tuple = (10, 7),
        dpi: int = 600,
        py_path: str = os.path.dirname(os.path.abspath(__file__)),
    ):
        # 数据配置
        DATA_CONFIG["app"] = self
        DATA_CONFIG["dx"] = dx
        DATA_CONFIG["time_interval"] = time_interval
        DATA_CONFIG["plot_max_points"] = plot_max_points
        DATA_CONFIG["port_timeout"] = port_timeout
        DATA_CONFIG["py_path"] = py_path
        DATA_CONFIG["std_limit"] = std_limit
        DATA_CONFIG["time_lower_limit"] = time_lower_limit
        DATA_CONFIG["time_upper_limit"] = time_upper_limit
        DATA_CONFIG["width_height_inches"] = width_height_inches
        DATA_CONFIG["dpi"] = dpi

        # 初始化窗口
        DATA_CONFIG["window"] = ttk.Window(
            themename="sandstone",
            title="实验数据采集与处理软件 v1.0.0",
        )

        try:
            if sys.platform.startswith("darwin"):
                DATA_CONFIG["window"].iconphoto(
                    True,
                    PhotoImage(file="logos/ce.png"),
                )
            else:
                DATA_CONFIG["window"].iconbitmap("logos/ce.ico")
        except:
            pass

        # 设置窗口最小尺寸
        min_height = 960
        min_width = int(min_height * 4 / 3)
        DATA_CONFIG["window"].minsize(min_width, min_height)
        DATA_CONFIG["window"].geometry(f"{min_width}x{min_height}")

        # 获取屏幕尺寸
        screen_height = DATA_CONFIG["window"].winfo_screenheight()
        screen_width = DATA_CONFIG["window"].winfo_screenwidth()

        # 默认窗口尺寸为屏幕高度的75%，比例4:3
        default_height = int(screen_height * 0.75)
        default_width = int(screen_height * 0.75 * 4 / 3)

        # 根据屏幕尺寸调整窗口尺寸
        if (screen_height < min_height) or (screen_width < min_height):
            if (screen_height * 0.75 * 4 / 3) > min_width:
                default_height = int(screen_height * 0.75)
                default_width = int(screen_height * 0.75 * 4 / 3)
                DATA_CONFIG["window"].geometry(f"{default_width}x{default_height}")

        # 窗口左上角显示
        DATA_CONFIG["window"].geometry("+0+0")

        # 创建所有屏幕实例
        self.screens = {
            "filteration_screen": Filteration_Screen(DATA_CONFIG["window"]),
            "heat_transfer_screen": Heat_Transfer_Screen(DATA_CONFIG["window"]),
            "extraction_screen": Extraction_Screen(DATA_CONFIG["window"]),
            "drying_screen": Drying_Screen(DATA_CONFIG["window"]),
            "oxygen_desorption_screen": Oxygen_Desorption_Screen(DATA_CONFIG["window"]),
            "distillation_screen": Distillation_Screen(DATA_CONFIG["window"]),
            "fluid_flow_screen": Fluid_Flow_Screen(DATA_CONFIG["window"]),
        }

        # 初始化 current_screen
        self.current_screen = None

        # 创建模式切换菜单
        self._create_mode_menu()

        # 默认显示过滤实验屏幕
        self.show_screen("filteration_screen")

        # 主事件循环
        DATA_CONFIG["window"].mainloop()

    def _create_mode_menu(self):
        """创建模式切换菜单"""
        # 创建菜单栏
        menubar = ttk.Menu(DATA_CONFIG["window"])
        DATA_CONFIG["window"].config(menu=menubar)

        # 创建实验模式菜单
        mode_menu = ttk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="实验模式", menu=mode_menu)

        # 创建菜单项
        mode_menu.add_command(label="过滤实验", command=lambda: self.show_screen("filteration_screen"))
        mode_menu.add_command(label="传热实验", command=lambda: self.show_screen("heat_transfer_screen"))
        mode_menu.add_command(label="萃取实验", command=lambda: self.show_screen("extraction_screen"))
        mode_menu.add_command(label="干燥实验", command=lambda: self.show_screen("drying_screen"))
        mode_menu.add_command(label="解析实验", command=lambda: self.show_screen("oxygen_desorption_screen"))
        mode_menu.add_command(label="精馏实验", command=lambda: self.show_screen("distillation_screen"))
        mode_menu.add_command(label="流体实验", command=lambda: self.show_screen("fluid_flow_screen"))

    def show_screen(self, screen_name):
        """显示指定的屏幕"""
        if self.current_screen:
            self.current_screen.pack_forget()

        if screen_name in self.screens:
            self.current_screen = self.screens[screen_name]
            self.current_screen.pack(fill="both", expand=True)
        else:
            logging.error(f"未知屏幕名称: {screen_name}")

    def change_mode(self, *args):
        """界面模式切换，切换窗口"""
        event = DATA_CONFIG["mode"].get()
        if event == "过滤":
            self.show_screen("filteration_screen")
        elif event == "传热":
            self.show_screen("heat_transfer_screen")
        elif event == "萃取":
            self.show_screen("extraction_screen")
        elif event == "干燥":
            self.show_screen("drying_screen")
        elif event == "解析":
            self.show_screen("oxygen_desorption_screen")
        elif event == "精馏":
            self.show_screen("distillation_screen")
        elif event == "流体":
            self.show_screen("fluid_flow_screen")
        else:
            logging.error(f"未知模式: {event}")

    def data_changed(self):
        """数据修改响应函数（预留扩展）"""
        pass


================================================================================
E:\Chem-Experiment-Process-App\gui\__init__.py 的内容:
================================================================================


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\distillation_screen.py 的内容:
================================================================================
# distillation_screen.py

# 内部库
import sys
import os

# 动态获取项目根路径
current_script_path = os.path.abspath(__file__)
project_root = os.path.dirname(os.path.dirname(os.path.dirname(current_script_path)))
sys.path.insert(0, project_root)

import logging
import traceback
from tkinter import (
    Label,
    Toplevel,
    messagebox,
    ttk,
    Button,
    filedialog,
    Canvas,
    StringVar,
)
from tkinter.ttk import Progressbar
from PIL import Image, ImageTk
import numpy as np
import pandas as pd
import tkinter as tk

# 配置 logging 信息
logging.getLogger("matplotlib.font_manager").setLevel(logging.ERROR)
logging.getLogger("PIL").setLevel(logging.WARNING)
logging.basicConfig(level=logging.DEBUG, format="%(asctime)s - %(levelname)s - %(message)s")

# 导入界面配置和小部件
from gui.screens.utils.config import MAIN_FRAME_CONFIG, SCREEN_CONFIG
from gui.screens.common_widgets.table_widget import TableWidget
from gui.screens.common_widgets.plot_widget import PlotWidget
from gui.screens.common_widgets.text_widget import TextWidget
from gui.screens.processors.distillation_experiment_processor import Distillation_Experiment_Processor


class Distillation_Screen(ttk.Frame):
    """
    精馏实验界面类，包含数据处理、显示和导入功能。
    """

    def __init__(self, window):
        super().__init__(window)
        self.window = window
        self.csv_file_path = None  # 存储CSV文件路径
        self.processed_data = None
        self.current_page = 0
        self.images_paths = []
        self.RAW_COLS = []  # 动态生成列标题
        self._init_components()
        self.window.protocol("WM_DELETE_WINDOW", self.close_window)

    def _init_components(self):
        """初始化界面组件"""
        self.main_paned = ttk.PanedWindow(self, orient="horizontal")
        self.main_paned.pack(expand=True, fill="both")

        # 左侧面板
        self.left_frame = ttk.Frame(self.main_paned, width=600)
        self.main_paned.add(self.left_frame, weight=1)
        self._init_left_panel()

        # 右侧面板
        self.right_frame = ttk.Frame(self.main_paned, width=800)
        self.main_paned.add(self.right_frame, weight=2)
        self._init_right_panel()

    def _init_left_panel(self):
        """初始化左侧面板"""
        button_frame = ttk.Frame(self.left_frame)
        button_frame.pack(side="top", fill="x", padx=5, pady=5)

        # 导入数据按钮 - 修改为导入CSV文件
        self.import_data_btn = Button(button_frame, text="导入CSV数据", command=self.load_csv_data)
        self.import_data_btn.pack(side="left", padx=5, pady=5)

        # 处理数据按钮
        self.process_data_btn = Button(button_frame, text="处理数据", command=self.process_data)
        self.process_data_btn.pack(side="left", padx=5, pady=5)

        # 绘制图形按钮
        self.plot_graph_btn = Button(button_frame, text="绘制图形", command=self.plot_graph)
        self.plot_graph_btn.pack(side="left", padx=5, pady=5)

        # 原始数据表格
        self.raw_data_display = ttk.LabelFrame(self.left_frame, text="原始数据")
        self.raw_data_display.pack(pady=10, fill="both", expand=True)
        self.raw_data_table = TableWidget(self.raw_data_display, [], widths=[])  # 初始时为空
        self.raw_data_table.pack(pady=10, fill="both", expand=True)

        # 结果数据表格
        self.res_data_display = ttk.LabelFrame(self.left_frame, text="计算结果")
        self.res_data_display.pack(pady=10, fill="both", expand=True)
        self.res_data_table = TableWidget(self.res_data_display, [], widths=[])
        self.res_data_table.pack(pady=10, fill="both", expand=True)

    def _init_right_panel(self):
        """初始化右侧面板"""
        self.right_paned = ttk.PanedWindow(self.right_frame, orient="vertical")
        self.right_paned.pack(fill="both", expand=True)

        # 绘图区域
        self.plot_frame = ttk.Frame(self.right_paned)
        self.right_paned.add(self.plot_frame, weight=1)

        # 图像显示Canvas
        self.image_canvas = Canvas(self.plot_frame)
        self.image_canvas.pack(fill="both", expand=True)
        self.image_canvas.bind("<Configure>", self.on_resize)

        # 页码标签
        self.page_label = ttk.Label(self.right_frame, text="Page 1/1")
        self.page_label.pack(side="top", padx=5, pady=5)

        # 翻页按钮
        button_frame = ttk.Frame(self.right_frame)
        button_frame.pack(side="bottom", fill="x", padx=5, pady=10)

        self.prev_btn = ttk.Button(button_frame, text="上一页", command=self.show_prev_page, state="disabled")
        self.prev_btn.pack(side="left", padx=5, pady=5)

        self.next_btn = ttk.Button(button_frame, text="下一页", command=self.show_next_page, state="disabled")
        self.next_btn.pack(side="left", padx=5, pady=5)

    def load_csv_data(self):
        """加载CSV文件数据"""
        file_path = filedialog.askopenfilename(
            title="选择精馏实验CSV文件",
            filetypes=[("CSV Files", "*.csv")],
            initialdir="./",
        )

        if not file_path:
            return

        try:
            self.csv_file_path = file_path

            # 加载数据到表格显示
            df = pd.read_csv(file_path)
            # 动态生成列标题
            self.RAW_COLS = ["序号"] + df.columns.tolist()
            self.update_raw_data_table(df.values)

            messagebox.showinfo("成功", "文件加载完成！")

        except Exception as e:
            messagebox.showerror("错误", f"加载CSV数据失败：{str(e)}")
            logging.error(traceback.format_exc())

    def process_data(self):
        """处理数据"""
        if not self.csv_file_path:
            messagebox.showwarning("警告", "请先导入CSV数据！")
            return

        try:
            self.show_processing_window()

            # 创建处理器实例并处理数据
            self.processors = []
            self.processed_data_list = []

            # 处理 R=4 的情况
            processor_r4 = Distillation_Experiment_Processor(
                file_path=self.csv_file_path,
                R=4,  # 回流比
                αm=2.0,  # 默认相对挥发度
                F=80,  # 默认进料量
                tS=30,  # 默认塔顶温度
                tF=26,  # 默认塔底温度
                output_dir="实验结果/R4",
            )
            processor_r4.process_experiment(show_plot=False)  # 不显示图形
            self.processors.append(processor_r4)
            self.processed_data_list.append(processor_r4.calculator.results)

            # 处理 R=无穷大 的情况
            processor_r_inf = Distillation_Experiment_Processor(
                file_path=self.csv_file_path,
                R=10000,  # 回流比（近似无穷大）
                αm=2.0,  # 默认相对挥发度
                F=80,  # 默认进料量
                tS=30,  # 默认塔顶温度
                tF=26,  # 默认塔底温度
                output_dir="实验结果/R_inf",
            )
            processor_r_inf.process_experiment(show_plot=False)  # 不显示图形
            self.processors.append(processor_r_inf)
            self.processed_data_list.append(processor_r_inf.calculator.results)

            # 更新结果表格
            self.update_results_table()

            self.close_processing_window()
            messagebox.showinfo("成功", "数据处理完成！")

        except Exception as e:
            self.close_processing_window()
            messagebox.showerror("错误", f"数据处理失败：{str(e)}")
            logging.error(traceback.format_exc())

    def plot_graph(self):
        """绘制图形"""
        if not hasattr(self, "processors") or not self.processors:
            messagebox.showwarning("警告", "请先处理数据！")
            return

        try:
            self.show_processing_window()

            # 清空图像路径
            self.images_paths = []

            # 分别绘制两种回流比的图形
            for processor in self.processors:
                plot_path = processor.result_paths["visualization"]
                processor.plotter.plot_mccabe_thiele(save_path=plot_path, show=False)
                self.images_paths.append(plot_path)

            # 显示第一张图
            if self.images_paths:
                self.current_page = 0
                self.show_current_page()
                self.enable_page_buttons()

            self.close_processing_window()
            messagebox.showinfo("成功", "图形绘制完成！")

        except Exception as e:
            self.close_processing_window()
            messagebox.showerror("错误", f"绘制图形失败：{str(e)}")
            logging.error(traceback.format_exc())

    def update_raw_data_table(self, raw_data=None):
        """更新原始数据表格"""
        self.raw_data_table.clear()
        # 动态设置表格列
        self.raw_data_table.table["columns"] = self.RAW_COLS
        for col in self.RAW_COLS:
            self.raw_data_table.table.heading(col, text=col)
        if raw_data is not None:
            for idx, row in enumerate(raw_data):
                # 确保数据行的长度与列数匹配
                row_data = [idx + 1] + row.tolist()
                self.raw_data_table.append(row_data)

    def update_results_table(self):
        """更新结果表格"""
        self.res_data_table.clear()
        RESULT_COLS = ["组号", "回流比", "理论塔板数", "实际塔板数", "分离效率"]
        self.res_data_table.table["columns"] = RESULT_COLS
        for col in RESULT_COLS:
            self.res_data_table.table.heading(col, text=col)

        for idx, (processor, data) in enumerate(zip(self.processors, self.processed_data_list)):
            # 根据回流比区分情况
            if processor.R == 4:
                reflux_ratio = 4
            else:
                reflux_ratio = "无穷大"

            # 添加结果到表格
            self.res_data_table.append(
                [
                    idx + 1,
                    reflux_ratio,
                    f"{data['理论塔板数']:.2f}",
                    f"{data['理论塔板数'] - 1:.2f}",
                    "N/A",  # 分离效率需要根据具体实验计算
                ]
            )

    def show_processing_window(self):
        """显示处理中的窗口"""
        self.processing_window = Toplevel(self.window)
        self.processing_window.title("处理中")
        self.processing_window.geometry("200x100")
        label = ttk.Label(self.processing_window, text="正在处理，请稍候...")
        label.pack(expand=True)
        self.processing_window.grab_set()
        self.processing_window.update()

    def close_processing_window(self):
        """关闭处理中的窗口"""
        if hasattr(self, "processing_window"):
            self.processing_window.grab_release()
            self.processing_window.destroy()

    def show_current_page(self):
        """显示当前页的图形"""
        self.image_canvas.delete("all")
        if not self.images_paths or self.current_page >= len(self.images_paths):
            return

        try:
            img = Image.open(self.images_paths[self.current_page])
            canvas_width = self.image_canvas.winfo_width()
            canvas_height = self.image_canvas.winfo_height()

            # 保持宽高比缩放
            img_ratio = img.width / img.height
            canvas_ratio = canvas_width / canvas_height

            if canvas_ratio > img_ratio:
                new_height = canvas_height
                new_width = int(new_height * img_ratio)
            else:
                new_width = canvas_width
                new_height = int(new_width / img_ratio)

            img = img.resize((new_width, new_height), Image.Resampling.LANCZOS)
            img_tk = ImageTk.PhotoImage(img)

            # 居中显示
            x_pos = (canvas_width - new_width) // 2
            y_pos = (canvas_height - new_height) // 2

            self.image_canvas.create_image(x_pos, y_pos, image=img_tk, anchor="nw")
            self.image_canvas.image = img_tk

            # 更新页码
            self.page_label.config(text=f"Page {self.current_page + 1}/{len(self.images_paths)}")

        except Exception as e:
            logging.error(f"加载图像失败: {str(e)}")

    def on_resize(self, event):
        """处理画布大小变化"""
        if self.images_paths:
            self.show_current_page()

    def show_prev_page(self):
        """显示上一页"""
        if self.current_page > 0:
            self.current_page -= 1
            self.show_current_page()
        self.enable_page_buttons()  # 翻页后更新按钮状态

    def show_next_page(self):
        """显示下一页"""
        if self.current_page < len(self.images_paths) - 1:
            self.current_page += 1
            self.show_current_page()
        self.enable_page_buttons()  # 翻页后更新按钮状态

    def enable_page_buttons(self):
        """启用/禁用翻页按钮"""
        if not self.images_paths or len(self.images_paths) <= 1:
            self.prev_btn.config(state="disabled")
            self.next_btn.config(state="disabled")
        else:
            prev_state = "normal" if self.current_page > 0 else "disabled"
            next_state = "normal" if self.current_page < len(self.images_paths) - 1 else "disabled"
            self.prev_btn.config(state=prev_state)
            self.next_btn.config(state=next_state)

    def close_window(self):
        """关闭窗口"""
        self.window.destroy()


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\drying_screen.py 的内容:
================================================================================
# drying_screen.py

# 内部库
import sys
import os

# 动态获取项目根路径
current_script_path = os.path.abspath(__file__)
project_root = os.path.dirname(os.path.dirname(os.path.dirname(current_script_path)))
sys.path.insert(0, project_root)

import logging
import traceback
from tkinter import (
    Label,
    Toplevel,
    messagebox,
    ttk,
    Button,
    filedialog,
    Canvas,
    StringVar,
)
from tkinter.ttk import Progressbar
from PIL import Image, ImageTk
import numpy as np
import pandas as pd
import tkinter as tk

# 配置 logging 信息
logging.getLogger("matplotlib.font_manager").setLevel(logging.ERROR)
logging.getLogger("PIL").setLevel(logging.WARNING)
logging.basicConfig(level=logging.DEBUG, format="%(asctime)s - %(levelname)s - %(message)s")

# 导入界面配置和小部件
from gui.screens.utils.config import MAIN_FRAME_CONFIG, SCREEN_CONFIG
from gui.screens.common_widgets.table_widget import TableWidget
from gui.screens.processors.drying_experiment_processor import Drying_Experiment_Processor


class Drying_Screen(ttk.Frame):
    """
    干燥实验界面类，包含数据处理、显示和导入功能
    """

    RAW_COLS = ["时间τ/min", "总质量W1/g", "干球温度t_dry/℃", "湿球温度t_wet/℃"]
    RESULT_COLS = ["参数", "值"]

    def __init__(self, window):
        super().__init__(window)
        self.window = window
        self.csv_file_paths = None
        self.processed_data = None
        self.current_page = 0
        self.images_paths = []
        self._init_components()
        self.window.protocol("WM_DELETE_WINDOW", self.close_window)

    def _init_components(self):
        """初始化界面组件"""
        self.main_paned = ttk.PanedWindow(self, orient="horizontal")
        self.main_paned.pack(expand=True, fill="both")

        # 左侧面板
        self.left_frame = ttk.Frame(self.main_paned, width=600)
        self.main_paned.add(self.left_frame, weight=1)
        self._init_left_panel()

        # 右侧面板
        self.right_frame = ttk.Frame(self.main_paned, width=800)
        self.main_paned.add(self.right_frame, weight=2)
        self._init_right_panel()

    def _init_left_panel(self):
        """初始化左侧面板"""
        button_frame = ttk.Frame(self.left_frame)
        button_frame.pack(side="top", fill="x", padx=5, pady=5)

        # 导入数据按钮
        self.import_data_btn = Button(button_frame, text="导入CSV数据", command=self.load_csv_data)
        self.import_data_btn.pack(side="left", padx=5, pady=5)

        # 处理数据按钮
        self.process_data_btn = Button(button_frame, text="处理数据", command=self.process_data)
        self.process_data_btn.pack(side="left", padx=5, pady=5)

        # 绘制图形按钮
        self.plot_graph_btn = Button(button_frame, text="绘制图形", command=self.plot_graph)
        self.plot_graph_btn.pack(side="left", padx=5, pady=5)

        # 原始数据表格
        self.raw_data_display = ttk.LabelFrame(self.left_frame, text="原始数据")
        self.raw_data_display.pack(pady=10, fill="both", expand=True)
        self.raw_data_table = TableWidget(self.raw_data_display, self.RAW_COLS, widths=[100, 120, 120, 120])
        self.raw_data_table.pack(pady=10, fill="both", expand=True)

        # 结果数据表格
        self.res_data_display = ttk.LabelFrame(self.left_frame, text="计算结果")
        self.res_data_display.pack(pady=10, fill="both", expand=True)
        self.res_data_table = TableWidget(self.res_data_display, self.RESULT_COLS, widths=[100, 150])
        self.res_data_table.pack(pady=10, fill="both", expand=True)

    def _init_right_panel(self):
        """初始化右侧面板"""
        self.right_paned = ttk.PanedWindow(self.right_frame, orient="vertical")
        self.right_paned.pack(fill="both", expand=True)

        # 绘图区域
        self.plot_frame = ttk.Frame(self.right_paned)
        self.right_paned.add(self.plot_frame, weight=1)

        # 图像显示Canvas
        self.image_canvas = Canvas(self.plot_frame)
        self.image_canvas.pack(fill="both", expand=True)
        self.image_canvas.bind("<Configure>", self.on_resize)

        # 页码标签
        self.page_label = ttk.Label(self.right_frame, text="Page 1/1")
        self.page_label.pack(side="top", padx=5, pady=5)

        # 翻页按钮
        button_frame = ttk.Frame(self.right_frame)
        button_frame.pack(side="bottom", fill="x", padx=5, pady=10)

        self.prev_btn = ttk.Button(button_frame, text="上一页", command=self.show_prev_page, state="disabled")
        self.prev_btn.pack(side="left", padx=5, pady=5)

        self.next_btn = ttk.Button(button_frame, text="下一页", command=self.show_next_page, state="disabled")
        self.next_btn.pack(side="left", padx=5, pady=5)

    def load_csv_data(self):
        """加载干燥实验CSV文件"""
        file_paths = filedialog.askopenfilenames(
            title="选择干燥实验CSV文件（需包含原始数据1和原始数据2）",
            filetypes=[("CSV Files", "*.csv")],
            initialdir="./",
        )

        if not file_paths:
            return

        try:
            # 验证文件命名规范
            data1_path, data2_path = None, None
            for path in file_paths:
                filename = os.path.basename(path).lower()
                if "原始数据1" in filename:
                    data1_path = path
                elif "原始数据2" in filename:
                    data2_path = path

            if not all([data1_path, data2_path]):
                raise ValueError("必须包含原始数据1和原始数据2文件")

            # 加载原始数据2到表格显示
            df = pd.read_csv(data2_path, header=0, skiprows=[1])
            raw_data = df[["累计时间τ/min", "总质量W1/g", "干球温度t_dry/℃", "湿球温度t_wet/℃"]].values

            self.csv_file_paths = [data1_path, data2_path]
            self.update_raw_data_table(raw_data)

            messagebox.showinfo("成功", "文件加载完成！")

        except Exception as e:
            messagebox.showerror("错误", f"加载数据失败：{str(e)}")
            logging.error(traceback.format_exc())

    def process_data(self):
        """处理干燥实验数据"""
        if not self.csv_file_paths:
            messagebox.showwarning("警告", "请先导入CSV数据！")
            return

        try:
            self.show_processing_window()

            # 创建处理器实例
            self.processor = Drying_Experiment_Processor(self.csv_file_paths)
            outputs = self.processor.process_experiment()

            # 获取计算结果
            self.results = self.processor.get_results()
            self.images_paths = [
                outputs["combined_plot"],
                outputs["combined_plot"].replace("combined_plots", "drying_curve"),
                outputs["combined_plot"].replace("combined_plots", "drying_rate_curve"),
            ]

            # 更新结果表格
            self.update_results_table()

            self.close_processing_window()
            self.enable_page_buttons()
            messagebox.showinfo("成功", "数据处理完成！")
        except Exception as e:
            self.close_processing_window()
            messagebox.showerror("错误", f"数据处理失败：{str(e)}")
            logging.error(traceback.format_exc())

    def plot_graph(self):
        """生成并显示图表"""
        if not hasattr(self, "processor"):
            messagebox.showwarning("警告", "请先处理数据！")
            return

        try:
            self.show_processing_window()

            # 显示第一张图
            if self.images_paths:
                self.current_page = 0
                self.show_current_page()
                self.enable_page_buttons()

            self.close_processing_window()
            messagebox.showinfo("成功", "图表生成完成！")
        except Exception as e:
            self.close_processing_window()
            messagebox.showerror("错误", f"图表生成失败：{str(e)}")
            logging.error(traceback.format_exc())

    # 以下是通用方法，与传热界面保持一致
    def show_processing_window(self):
        """显示处理中的窗口"""
        self.processing_window = Toplevel(self.window)
        self.processing_window.title("处理中")
        self.processing_window.geometry("200x100")
        label = ttk.Label(self.processing_window, text="正在处理，请稍候...")
        label.pack(expand=True)
        self.processing_window.grab_set()
        self.processing_window.update()

    def close_processing_window(self):
        """关闭处理中的窗口"""
        if hasattr(self, "processing_window"):
            self.processing_window.grab_release()
            self.processing_window.destroy()

    def update_raw_data_table(self, raw_data=None):
        """更新原始数据表格"""
        self.raw_data_table.clear()
        if raw_data is not None:
            for row in raw_data:
                self.raw_data_table.append([row[0], row[1], row[2], row[3]])

    def update_results_table(self):
        """更新计算结果表格"""
        self.res_data_table.clear()
        if hasattr(self.processor, "U_c") and hasattr(self.processor, "α"):
            results = [
                ("恒定干燥速率 U_c (kg/m²·h)", f"{self.processor.U_c:.4f}"),
                ("传热系数 α (kW/m²·K)", f"{self.processor.α.mean():.4f}"),
                ("初始体积流量 V_t0 (m³/s)", f"{self.processor.V_t0:.6f}"),
            ]
            for param, value in results:
                self.res_data_table.append([param, value])

    def show_current_page(self):
        """显示当前页的图形"""
        self.image_canvas.delete("all")
        if not self.images_paths or self.current_page >= len(self.images_paths):
            return

        try:
            img = Image.open(self.images_paths[self.current_page])
            canvas_width = self.image_canvas.winfo_width()
            canvas_height = self.image_canvas.winfo_height()

            # 保持宽高比缩放
            img_ratio = img.width / img.height
            canvas_ratio = canvas_width / canvas_height

            if canvas_ratio > img_ratio:
                new_height = canvas_height
                new_width = int(new_height * img_ratio)
            else:
                new_width = canvas_width
                new_height = int(new_width / img_ratio)

            img = img.resize((new_width, new_height), Image.Resampling.LANCZOS)
            img_tk = ImageTk.PhotoImage(img)

            # 居中显示
            x_pos = (canvas_width - new_width) // 2
            y_pos = (canvas_height - new_height) // 2

            self.image_canvas.create_image(x_pos, y_pos, image=img_tk, anchor="nw")
            self.image_canvas.image = img_tk

            # 更新页码
            self.page_label.config(text=f"Page {self.current_page + 1}/{len(self.images_paths)}")
        except Exception as e:
            logging.error(f"加载图像失败: {str(e)}")

    def on_resize(self, event):
        """处理画布大小变化"""
        if self.images_paths:
            self.show_current_page()

    def show_prev_page(self):
        """显示上一页"""
        if self.current_page > 0:
            self.current_page -= 1
            self.show_current_page()
        self.enable_page_buttons()

    def show_next_page(self):
        """显示下一页"""
        if self.current_page < len(self.images_paths) - 1:
            self.current_page += 1
            self.show_current_page()
        self.enable_page_buttons()

    def enable_page_buttons(self):
        """启用/禁用翻页按钮"""
        if not self.images_paths or len(self.images_paths) <= 1:
            self.prev_btn.config(state="disabled")
            self.next_btn.config(state="disabled")
        else:
            prev_state = "normal" if self.current_page > 0 else "disabled"
            next_state = "normal" if self.current_page < len(self.images_paths) - 1 else "disabled"
            self.prev_btn.config(state=prev_state)
            self.next_btn.config(state=next_state)

    def close_window(self):
        """关闭窗口"""
        self.window.destroy()


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\extraction_screen.py 的内容:
================================================================================
# extraction_screen.py

# 内部库
import sys
import os

# 动态获取项目根路径
current_script_path = os.path.abspath(__file__)
project_root = os.path.dirname(os.path.dirname(os.path.dirname(current_script_path)))
sys.path.insert(0, project_root)

import logging
import traceback
import tkinter as tk

from tkinter import ttk, Button, filedialog, Canvas, messagebox, Toplevel, Label
from PIL import Image, ImageTk
from pathlib import Path
import pandas as pd

# 配置日志和路径
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
# 导入界面配置和小部件
from gui.screens.utils.config import MAIN_FRAME_CONFIG, SCREEN_CONFIG
from gui.screens.common_widgets.plot_widget import PlotWidget
from gui.screens.common_widgets.table_widget import TableWidget
from gui.screens.common_widgets.text_widget import TextWidget

# 导入萃取处理模块
from gui.screens.calculators.extraction_calculator import Extraction_Calculator
from gui.screens.plotters.extraction_plotter import Extraction_Plotter


class Extraction_Screen(ttk.Frame):
    """
    萃取实验界面类
    -------------------------
    功能：
    1. 数据导入与展示
    2. 实验数据处理
    3. 可视化结果展示
    4. 结果打包导出
    """

    RAW_COLS = ["实验项目", "项目一", "项目二"]
    RESULT_COLS = ["参数", "项目一", "项目二", "项目三", "项目四"]

    def __init__(self, master):
        super().__init__(master)
        self.master = master
        self._init_ui()
        self._setup_bindings()

        # 实验数据相关属性
        self.calculator = None
        self.plotter = None
        self.current_page = 0
        self.image_paths = []
        self.file_dict = {"main": None, "distribution": None}  # 初始化文件字典

    def _init_ui(self):
        """初始化用户界面"""
        self._create_main_panes()
        self._create_left_panel()
        self._create_right_panel()
        self._configure_styles()

    def _create_main_panes(self):
        """创建主布局面板"""
        self.main_pane = ttk.PanedWindow(self, orient="horizontal")
        self.main_pane.pack(fill="both", expand=True)

        # 左侧控制面板
        self.left_frame = ttk.Frame(self.main_pane, width=300)
        self.main_pane.add(self.left_frame, weight=1)

        # 右侧可视化面板
        self.right_frame = ttk.Frame(self.main_pane)
        self.main_pane.add(self.right_frame, weight=3)

    def _create_left_panel(self):
        """创建左侧控制面板"""
        # 按钮区域
        btn_frame = ttk.Frame(self.left_frame)
        btn_frame.pack(pady=10, fill="x")

        Button(btn_frame, text="导入数据", command=self.load_data).pack(fill="x", pady=2)
        Button(btn_frame, text="计算参数", command=self.process_data).pack(fill="x", pady=2)
        Button(btn_frame, text="生成图表", command=self.generate_plots).pack(fill="x", pady=2)
        Button(btn_frame, text="导出结果", command=self.export_results).pack(fill="x", pady=2)

        # 原始数据表格
        self.raw_table = ttk.Treeview(self.left_frame, columns=self.RAW_COLS, show="headings", height=10)
        for col in self.RAW_COLS:
            self.raw_table.heading(col, text=col)
            self.raw_table.column(col, width=100, anchor="center")
        self.raw_table.pack(fill="both", expand=True, padx=5, pady=5)

        # 结果表格
        self.result_table = ttk.Treeview(self.left_frame, columns=self.RESULT_COLS, show="headings", height=5)
        for col in self.RESULT_COLS:
            self.result_table.heading(col, text=col)
            self.result_table.column(col, width=100, anchor="center")
        self.result_table.pack(fill="both", expand=True, padx=5, pady=5)

        # 文件状态显示
        self.file_status = ttk.Label(
            self.left_frame, text="已加载文件：\n主数据：无\n分配曲线：无", wraplength=280, anchor="w"
        )
        self.file_status.pack(fill="x", pady=5)

    def _create_right_panel(self):
        """创建右侧可视化面板"""
        # 画布区域
        self.canvas = Canvas(self.right_frame, bg="white")
        self.canvas.pack(fill="both", expand=True)

        # 分页控制
        control_frame = ttk.Frame(self.right_frame)
        control_frame.pack(pady=10)

        self.prev_btn = Button(control_frame, text="上一页", command=self.prev_page)
        self.prev_btn.pack(side="left", padx=5)
        self.page_label = ttk.Label(control_frame, text="第1页/共0页")
        self.page_label.pack(side="left", padx=5)
        self.next_btn = Button(control_frame, text="下一页", command=self.next_page)
        self.next_btn.pack(side="left", padx=5)

    def _configure_styles(self):
        """配置界面样式"""
        style = ttk.Style()
        style.configure("TButton", padding=6)
        style.configure("Treeview.Heading", font=("Microsoft YaHei", 10, "bold"))
        style.configure("Treeview", rowheight=25)

    def _setup_bindings(self):
        """设置事件绑定"""
        self.canvas.bind("<Configure>", self._resize_image)

    def _identify_file_type(self, filename):
        """根据文件名识别文件类型（增强版）"""
        filename = filename.lower()
        patterns = {
            "main": ["原始数据", "main", "数据记录", "_m", "input"],
            "distribution": ["分配曲线", "distribution", "dataset", "_d", "curve"],
        }

        for file_type, keywords in patterns.items():
            if any(kw in filename for kw in keywords):
                return file_type
        return None

    def load_data(self):
        """加载CSV格式的实验数据"""
        file_paths = filedialog.askopenfilenames(title="选择CSV数据文件", filetypes=[("CSV Files", "*.csv")])

        if not file_paths:
            return

        # 清空旧数据
        self.file_dict = {"main": None, "distribution": None}
        self.image_paths = []
        self.current_page = 0
        self._update_page_info()

        # 识别文件类型
        unrecognized = []
        for path in file_paths:
            file_type = self._identify_file_type(os.path.basename(path))
            if file_type:
                if self.file_dict[file_type]:  # 已存在同类型文件
                    confirm = messagebox.askyesno("确认", f"已加载{file_type}文件，是否替换？")
                    if not confirm:
                        continue
                self.file_dict[file_type] = path
            else:
                unrecognized.append(os.path.basename(path))

        # 显示未识别文件警告
        if unrecognized:
            self.show_warning(
                f"以下文件未能识别：\n{', '.join(unrecognized)}\n请确保文件名包含'原始数据'或'分配曲线'关键词"
            )

        # 验证必要文件
        missing = [k for k, v in self.file_dict.items() if not v]
        if missing:
            self.show_error(f"缺少必要文件类型：{', '.join(missing)}")
            return

        # 状态更新
        self._update_file_status()

        try:
            # 加载主数据
            main_df = pd.read_csv(self.file_dict["main"])
            self._update_raw_table(main_df)

        except Exception as e:
            self.show_error(f"CSV文件读取失败: {str(e)}")
            logging.error(traceback.format_exc())

    def _update_file_status(self):
        """更新文件状态显示"""
        main_file = os.path.basename(self.file_dict["main"]) if self.file_dict["main"] else "无"
        dist_file = os.path.basename(self.file_dict["distribution"]) if self.file_dict["distribution"] else "无"
        self.file_status.config(text=f"已加载文件：\n主数据：{main_file}\n分配曲线：{dist_file}")

    def _update_raw_table(self, df):
        """更新原始数据表格"""
        # 验证数据列数
        if df.shape[1] != len(self.RAW_COLS):
            self.show_error(f"数据列数不匹配！需要{len(self.RAW_COLS)}列，实际{df.shape[1]}列")
            return

        self.raw_table.delete(*self.raw_table.get_children())
        for _, row in df.iterrows():
            self.raw_table.insert("", "end", values=row.tolist())

    def process_data(self):
        """执行数据处理（增加文件存在性检查）"""
        if not all(self.file_dict.values()):
            self.show_warning("请先导入完整的数据文件！")
            return

        # 检查文件是否存在
        missing_files = []
        for ft, path in self.file_dict.items():
            if not os.path.exists(path):
                missing_files.append(ft)
        if missing_files:
            self.show_error(f"文件已丢失：{', '.join(missing_files)}")
            return

        try:
            self.show_processing("正在计算...")

            # 初始化计算模块
            self.calculator = Extraction_Calculator(
                main_file=self.file_dict["main"], distribution_file=self.file_dict["distribution"]
            )
            self.calculator.run_calculations()

            # 更新结果表格
            self._update_result_table()
            self.close_processing()

        except Exception as e:
            self.close_processing()
            self.show_error(f"数据处理失败: {str(e)}")
            logging.error(traceback.format_exc())

    def _update_result_table(self):
        """更新结果表格（优化数值显示）"""
        # 确保系数列表有4个元素
        coefficients = self.calculator.coefficients
        if len(coefficients) != 4:
            self.show_error("拟合系数数量异常！")
            return

        results = [
            [
                "分配系数的拟合项系数",
                f"{coefficients[0]:.4f}",  # x³项
                f"{coefficients[1]:.4f}",  # x²项
                f"{coefficients[2]:.4f}",  # x项
                f"{coefficients[3]:.4f}",  # 常数项
            ],
            ["操作线斜率", f"{self.calculator.k1:.2f}", f"{self.calculator.k2:.2f}", "", ""],  # 空值留白  # 空值留白
            [
                "积分结果",
                f"{self.calculator.ans3[0]:.3e}",
                f"{self.calculator.ans3[1]:.3e}",
                "",  # 空值留白
                "",  # 空值留白
            ],
        ]
        self.result_table.delete(*self.result_table.get_children())
        for row in results:
            self.result_table.insert("", "end", values=row)

    def generate_plots(self):
        """生成可视化图表"""
        if self.calculator is None:
            self.show_warning("请先进行数据处理！")
            return

        try:
            self.show_processing("正在生成图表...")

            # 初始化绘图模块
            self.plotter = Extraction_Plotter(self.calculator)
            self.plotter.create_output_dir()
            self.plotter.plot_main_curves()
            self.plotter.plot_integration_curves()

            # 获取生成的图表路径
            self.image_paths = [
                os.path.join(self.plotter.output_dir, f)
                for f in os.listdir(self.plotter.output_dir)
                if f.endswith(".png")
            ]

            self.current_page = 0
            self._update_page_info()
            self.show_current_image()
            self.close_processing()

        except Exception as e:
            self.close_processing()
            self.show_error(f"图表生成失败: {str(e)}")
            logging.error(traceback.format_exc())

    def export_results(self):
        """导出结果文件"""
        if self.plotter is None:
            self.show_warning("请先生成图表！")
            return

        try:
            self.plotter.package_results("萃取实验结果.zip")
            messagebox.showinfo("导出成功", "结果文件已保存为：萃取实验结果.zip")
        except Exception as e:
            self.show_error(f"导出失败: {str(e)}")

    def show_current_image(self):
        """显示当前页图像"""
        self.canvas.delete("all")
        if self.image_paths:
            try:
                img_path = self.image_paths[self.current_page]
                img = Image.open(img_path)
                self._display_image(img)
            except Exception as e:
                self.show_error(f"图像加载失败: {str(e)}")

    def _display_image(self, img):
        """在画布上显示图像"""
        canvas_width = self.canvas.winfo_width()
        canvas_height = self.canvas.winfo_height()

        # 保持宽高比缩放
        img_ratio = img.width / img.height
        canvas_ratio = canvas_width / canvas_height

        if img_ratio > canvas_ratio:
            new_width = canvas_width
            new_height = int(canvas_width / img_ratio)
        else:
            new_height = canvas_height
            new_width = int(canvas_height * img_ratio)

        img = img.resize((new_width, new_height), Image.LANCZOS)
        self.tk_img = ImageTk.PhotoImage(img)
        self.canvas.create_image(
            (canvas_width - new_width) // 2,
            (canvas_height - new_height) // 2,
            image=self.tk_img,
            anchor="nw",
        )

    def _resize_image(self, event):
        """响应画布尺寸变化"""
        self.show_current_image()

    def prev_page(self):
        """显示上一页"""
        if self.current_page > 0:
            self.current_page -= 1
            self._update_page_info()
            self.show_current_image()

    def next_page(self):
        """显示下一页"""
        if self.current_page < len(self.image_paths) - 1:
            self.current_page += 1
            self._update_page_info()
            self.show_current_image()

    def _update_page_info(self):
        """更新分页信息"""
        total = len(self.image_paths)
        current = self.current_page + 1
        self.page_label.config(text=f"第{current}页/共{total}页")

    def show_processing(self, msg="处理中..."):
        """显示处理中窗口"""
        self.processing_win = Toplevel(self.master)
        self.processing_win.title("请稍候")
        Label(self.processing_win, text=msg).pack(padx=20, pady=10)
        self.processing_win.grab_set()

    def close_processing(self):
        """关闭处理中窗口"""
        if hasattr(self, "processing_win"):
            self.processing_win.destroy()

    def show_error(self, msg):
        """显示错误提示"""
        messagebox.showerror("错误", msg)

    def show_warning(self, msg):
        """显示警告提示"""
        messagebox.showwarning("警告", msg)


if __name__ == "__main__":
    root = tk.Tk()
    root.title("萃取实验分析系统")
    root.geometry("1200x800")
    Extraction_Screen(root).pack(fill="both", expand=True)
    root.mainloop()


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\filteration_screen.py 的内容:
================================================================================
# filteration_screen.py

# 内部库
import sys
import os

# 动态获取项目根路径
current_script_path = os.path.abspath(__file__)
project_root = os.path.dirname(os.path.dirname(os.path.dirname(current_script_path)))
sys.path.insert(0, project_root)

import logging
import traceback

from tkinter import (
    Label,
    PhotoImage,
    Toplevel,
    messagebox,
    ttk,
    Button,
    filedialog,
    Canvas,
)

# 从 PIL 导入 Image (tkinter也有Image但是功能不如PIL强大) 和 ImageTk
from PIL import Image, ImageTk

# 设置matplotlib日志级别为ERROR，避免显示findfont的DEBUG信息
logging.getLogger("matplotlib.font_manager").setLevel(logging.ERROR)

# 设置Pillow日志级别为WARNING，避免显示DEBUG信息
logging.getLogger("PIL").setLevel(logging.WARNING)

# 配置日志设置
logging.basicConfig(level=logging.DEBUG, format="%(asctime)s - %(levelname)s - %(message)s")

# 导入必要的库
import pandas as pd

# 导入界面配置和小部件
from gui.screens.utils.config import MAIN_FRAME_CONFIG, SCREEN_CONFIG
from gui.screens.common_widgets.plot_widget import PlotWidget
from gui.screens.common_widgets.table_widget import TableWidget
from gui.screens.common_widgets.text_widget import TextWidget

# 导入数据处理类
from gui.screens.processors.filteration_experiment_processor import Filteration_Experiment_Processor


class Filteration_Screen(ttk.Frame):
    """
    过滤实验界面类，包含数据处理、显示和导入功能。
    """

    RAW_COLS = ["行号", "索引", "滤面高度 (cm)", "时间θ (s)", "时间差Δθ (s)"]
    RESULT_COLS = ["组号", "斜率", "截距"]

    def __init__(self, window):
        super().__init__(window, **SCREEN_CONFIG)
        self.window = window
        self.csv_file_path = None
        self.processed_data = None
        self.after_id = None  # 用于存储定时调用的ID，方便取消定时调用
        self.current_page = 0  # 当前页，控制显示的图形
        self.images_paths = []  # 存储图像文件路径
        self._init_components()

        # 将窗口关闭事件绑定到close_window方法
        self.window.protocol("WM_DELETE_WINDOW", self.close_window)

    def _init_components(self):
        """初始化界面组件，包括表格、按钮和绘图区域。"""
        self.main_paned = ttk.PanedWindow(self, orient="horizontal")
        self.main_paned.pack(expand=True, fill="both")

        self.left_frame = ttk.Frame(self.main_paned, **MAIN_FRAME_CONFIG)
        self.main_paned.add(self.left_frame, weight=1)

        self.right_frame = ttk.Frame(self.main_paned, **MAIN_FRAME_CONFIG)
        self.main_paned.add(self.right_frame, weight=2)

        self.csv_file_path_table = TableWidget(self.left_frame, self.RAW_COLS, widths=[10, 40, 40, 40])

        self._init_left_panel()
        self._init_right_panel()

    def _init_left_panel(self):
        """初始化左侧面板，包含按钮和表格区域。"""
        self.left_paned = ttk.PanedWindow(self.left_frame, orient="vertical")
        self.left_paned.pack(expand=True, fill="both")

        button_frame = ttk.Frame(self.left_frame)
        button_frame.pack(side="top", fill="x", padx=5, pady=5)

        # 定义按钮及其功能
        self.com_port_btn = Button(button_frame, text="通信串口", command=self._open_serial_port)
        self.com_port_btn.pack(side="top", fill="x", padx=5, pady=5)

        self.import_data_btn = Button(button_frame, text="导入数据", command=self.load_csv_data)
        self.import_data_btn.pack(side="top", fill="x", padx=5, pady=5)

        self.process_data_btn = Button(button_frame, text="处理数据", command=self.process_data)
        self.process_data_btn.pack(side="top", fill="x", padx=5, pady=5)

        self.plot_graph_btn = Button(button_frame, text="绘制图形", command=self.plot_graph)
        self.plot_graph_btn.pack(side="top", fill="x", padx=5, pady=5)

        # 显示原始数据表格
        self.raw_data_display = ttk.LabelFrame(self.left_frame)
        self.left_paned.add(self.raw_data_display, weight=1)

        self.raw_data_table = TableWidget(self.raw_data_display, self.RAW_COLS, widths=[10, 10, 15, 15, 15])
        self.raw_data_table.pack(pady=10, fill="both", expand=True)

        # 显示处理结果数据表格
        self.res_data_display = ttk.LabelFrame(self.left_frame)
        self.left_paned.add(self.res_data_display, weight=1)

        self.res_data_table = TableWidget(self.res_data_display, self.RESULT_COLS, widths=[10, 40, 40])
        self.res_data_table.pack(pady=10, fill="both", expand=True)

        self.left_paned.update_idletasks()

    def _init_right_panel(self):
        """初始化右侧面板，包含绘图区域和文本输出区。"""
        self.right_paned = ttk.PanedWindow(self.right_frame, orient="vertical")
        self.right_paned.pack(fill="both", expand=True)

        # 绘图的主面板
        self.image_panel = ttk.Frame(self.right_paned)
        self.right_paned.add(self.image_panel, weight=1)

        # 创建显示图像的Canvas
        self.image_canvas = Canvas(self.image_panel)
        self.image_canvas.pack(fill="both", expand=True)

        # 绑定调整画布大小的事件
        self.image_canvas.bind("<Configure>", self.on_resize)

        # 页码标签
        self.page_label = ttk.Label(self.right_frame, text="Page 1")
        self.page_label.pack(side="top", padx=5, pady=5)

        # 底部按钮
        button_frame = ttk.Frame(self.right_frame)
        button_frame.pack(side="bottom", fill="x", padx=5, pady=10)

        button_container = ttk.Frame(button_frame)
        button_container.pack(side="top", padx=10, pady=5)  # 按钮之间的间距

        self.prev_btn = Button(button_container, text="上一页", command=self.prev_page)
        self.prev_btn.pack(side="left", padx=5, pady=5)

        self.next_btn = Button(button_container, text="下一页", command=self.next_page)
        self.next_btn.pack(side="left", padx=5, pady=5)

    def show_processing_window(self):
        """弹出正在处理窗口"""
        self.processing_window = Toplevel(self.window)
        self.processing_window.title("Processing")
        self.processing_window.geometry("200x100")
        label = Label(self.processing_window, text="正在处理，请稍候...")
        label.pack(expand=True)
        self.processing_window.update()  # 强制更新，显示窗口

    def close_processing_window(self):
        """关闭正在处理窗口"""
        if hasattr(self, "processing_window"):
            self.processing_window.destroy()

    def process_data(self):
        """处理数据，当点击“处理数据”按钮时调用。"""
        if self.csv_file_path is None:
            messagebox.showwarning("Warning", "Please import data first!")
            return

        try:
            # 弹出处理中的窗口
            self.show_processing_window()

            # 创建Filteration_Experiment_Processor实例
            self.processor = Filteration_Experiment_Processor(self.csv_file_path)

            # 执行数据处理
            self.processor.calculate()  # 处理数据（计算、拟合等）
            self.processor.store()  # 存储处理后的数据

            self.processed_data = self.processor.processed_data

            # 更新结果表格
            self.update_results_table(self.processed_data)

            # 更新图像路径
            self.images_paths = self.processor.plotter.images_paths  # 获取生成的图像路径

            # 完成处理后关闭“正在处理”窗口
            self.close_processing_window()

        except Exception as e:
            self.close_processing_window()
            messagebox.showerror("Error", f"Error processing data: {e}")

    def plot_graph(self):
        """绘制图形并在右侧面板显示"""
        if not hasattr(self, "processor") or self.processor is None:
            messagebox.showwarning("Warning", "Please process data first!")
            return

        try:
            # 弹出处理中的窗口
            self.show_processing_window()

            # 直接调用生成图形的方法
            self.processor.plot()

            # 压缩生成的结果图像文件
            self.processor.compress_results()

            # 更新图像路径
            self.images_paths = self.processor.plotter.images_paths

            # 完成处理后关闭“正在处理”窗口
            self.close_processing_window()

            # 自动刷新显示页面
            self.show_page()

        except Exception as e:
            self.close_processing_window()
            messagebox.showerror("Error", f"Error plotting graph: {e}")

    def on_resize(self, event):
        """处理窗口大小调整，动态调整图像大小"""
        if self.images_paths:
            self.show_page()

    def show_page(self):
        """显示当前页的图形"""
        self.image_canvas.delete("all")  # 清空画布

        if self.images_paths:
            img_path = self.images_paths[self.current_page]
            try:
                img = Image.open(img_path)
                canvas_width = self.image_canvas.winfo_width()
                canvas_height = self.image_canvas.winfo_height()

                # 使用resize方法调整图像大小，保持宽高比
                img = img.resize((canvas_width, canvas_height), Image.Resampling.LANCZOS)

                img_tk = ImageTk.PhotoImage(img)
                self.image_canvas.create_image(0, 0, image=img_tk, anchor="nw")
                self.image_canvas.image = img_tk  # 保持对图像的引用

            except Exception as e:
                print(f"Error loading image {img_path}: {e}")

        # 更新页码
        self.page_label.config(text=f"Page {self.current_page + 1}")

        # 取消之前的定时调用（如果存在）
        if self.after_id is not None:
            self.window.after_cancel(self.after_id)

        # 安排下一个更新
        self.after_id = self.window.after(100, self.show_page)

    def close_window(self):
        """关闭窗口并取消所有待定的任务"""
        if self.after_id is not None:
            self.window.after_cancel(self.after_id)  # 取消待定的任务
        self.window.destroy()  # 关闭窗口

    def prev_page(self):
        """显示上一页的图形"""
        if self.current_page > 0:
            self.current_page -= 1
            self.show_page()

    def next_page(self):
        """显示下一页的图形"""
        if self.current_page < len(self.images_paths) - 1:
            self.current_page += 1
            self.show_page()

    def _open_serial_port(self):
        pass

    def load_csv_data(self):
        """加载CSV文件并预处理数据。"""
        file_path = filedialog.askopenfilename(title="选择CSV文件", filetypes=[("CSV Files", "*.csv")])

        if file_path:
            try:
                data = pd.read_csv(file_path, header=0)
                for col in data.columns:
                    data[col] = pd.to_numeric(data[col], errors="coerce")
                data = data.dropna()

                self.csv_file_path = file_path
                self.update_raw_data_table(data)

            except Exception as e:
                messagebox.showerror("Error", f"Error loading data: {e}")

    def update_raw_data_table(self, raw_data=None):
        """更新原始数据表格。"""
        if isinstance(self.raw_data_table, TableWidget):
            self.raw_data_table.clear()
            self.raw_data_table.table["columns"] = self.RAW_COLS
            for col in self.RAW_COLS:
                self.raw_data_table.table.heading(col, text=col)
            if raw_data is not None:
                df = pd.DataFrame(raw_data)
                for idx, row in df.iterrows():
                    self.raw_data_table.append([idx] + row.tolist())

    def update_results_table(self, processed_data=None):
        """更新处理后的结果表格。"""
        if isinstance(self.res_data_table, TableWidget):
            self.res_data_table.clear()
            self.res_data_table.table["columns"] = self.RESULT_COLS
            for col in self.RESULT_COLS:
                self.res_data_table.table.heading(col, text=col)
            if processed_data is not None:
                for result in processed_data:
                    self.res_data_table.append([result["group"], result["slope"], result["intercept"]])


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\fluid_flow_screen.py 的内容:
================================================================================
# fluid_flow_screen.py

# 内部库
import sys
import os

# 动态获取项目根路径
current_script_path = os.path.abspath(__file__)
project_root = os.path.dirname(os.path.dirname(os.path.dirname(current_script_path)))
sys.path.insert(0, project_root)

import logging
import traceback
from tkinter import (
    Label,
    Toplevel,
    messagebox,
    ttk,
    Button,
    filedialog,
    Canvas,
    StringVar,
)
from tkinter.ttk import Progressbar
from PIL import Image, ImageTk
import numpy as np
import pandas as pd

# 配置日志设置
# 保留自己代码的DEBUG日志，过滤第三方库的
logging.basicConfig(level=logging.DEBUG, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s")

# 设置第三方库的日志级别
logging.getLogger("matplotlib").setLevel(logging.WARNING)
logging.getLogger("PIL").setLevel(logging.WARNING)
logging.getLogger("numpy").setLevel(logging.WARNING)
logging.getLogger("pandas").setLevel(logging.WARNING)

# 动态获取项目根路径
current_script_path = os.path.abspath(__file__)
project_root = os.path.dirname(os.path.dirname(os.path.dirname(current_script_path)))
sys.path.insert(0, project_root)

# 导入界面配置和小部件
from gui.screens.utils.config import MAIN_FRAME_CONFIG, SCREEN_CONFIG
from gui.screens.common_widgets.plot_widget import PlotWidget
from gui.screens.common_widgets.table_widget import TableWidget
from gui.screens.common_widgets.text_widget import TextWidget

# 实验处理器类
from gui.screens.processors.fluid_flow_experiment_processor import Fluid_Flow_Expriment_Processor


class Fluid_Flow_Screen(ttk.Frame):
    """
    流体流动实验界面类，包含数据处理、显示和导入功能。
    """

    RAW_COLS = ["序号", "Q/(L/h)", "直管阻力压降/kPa", "温度t/℃"]
    RESULT_COLS = ["组号", "Re", "λ", "H/m", "N/kW", "η/%"]

    def __init__(self, window):
        super().__init__(window)
        self.window = window
        self.csv_file_paths = None  # 改为存储CSV文件路径列表
        self.processed_data = None
        self.current_page = 0
        self.images_paths = []
        self._init_components()
        self.window.protocol("WM_DELETE_WINDOW", self.close_window)

    def _init_components(self):
        """初始化界面组件"""
        self.main_paned = ttk.PanedWindow(self, orient="horizontal")
        self.main_paned.pack(expand=True, fill="both")

        # 左侧面板
        self.left_frame = ttk.Frame(self.main_paned, width=600)
        self.main_paned.add(self.left_frame, weight=1)
        self._init_left_panel()

        # 右侧面板
        self.right_frame = ttk.Frame(self.main_paned, width=800)
        self.main_paned.add(self.right_frame, weight=2)
        self._init_right_panel()

    def _init_left_panel(self):
        """初始化左侧面板"""
        button_frame = ttk.Frame(self.left_frame)
        button_frame.pack(side="top", fill="x", padx=5, pady=5)

        # 导入数据按钮 - 修改为导入CSV文件
        self.import_data_btn = Button(button_frame, text="导入CSV数据", command=self.load_csv_data)
        self.import_data_btn.pack(side="left", padx=5, pady=5)

        # 处理数据按钮
        self.process_data_btn = Button(button_frame, text="处理数据", command=self.process_data)
        self.process_data_btn.pack(side="left", padx=5, pady=5)

        # 绘制图形按钮
        self.plot_graph_btn = Button(button_frame, text="绘制图形", command=self.plot_graph)
        self.plot_graph_btn.pack(side="left", padx=5, pady=5)

        # 原始数据表格
        self.raw_data_display = ttk.LabelFrame(self.left_frame, text="原始数据")
        self.raw_data_display.pack(pady=10, fill="both", expand=True)
        self.raw_data_table = TableWidget(self.raw_data_display, self.RAW_COLS, widths=[60, 120, 120, 120])
        self.raw_data_table.pack(pady=10, fill="both", expand=True)

        # 结果数据表格
        self.res_data_display = ttk.LabelFrame(self.left_frame, text="计算结果")
        self.res_data_display.pack(pady=10, fill="both", expand=True)
        self.res_data_table = TableWidget(self.res_data_display, self.RESULT_COLS, widths=[60, 120, 120, 120, 120, 120])
        self.res_data_table.pack(pady=10, fill="both", expand=True)

    def _init_right_panel(self):
        """初始化右侧面板"""
        self.right_paned = ttk.PanedWindow(self.right_frame, orient="vertical")
        self.right_paned.pack(fill="both", expand=True)

        # 绘图区域
        self.plot_frame = ttk.Frame(self.right_paned)
        self.right_paned.add(self.plot_frame, weight=1)

        # 图像显示Canvas
        self.image_canvas = Canvas(self.plot_frame)
        self.image_canvas.pack(fill="both", expand=True)
        self.image_canvas.bind("<Configure>", self.on_resize)

        # 页码标签
        self.page_label = ttk.Label(self.right_frame, text="Page 1/1")
        self.page_label.pack(side="top", padx=5, pady=5)

        # 翻页按钮
        button_frame = ttk.Frame(self.right_frame)
        button_frame.pack(side="bottom", fill="x", padx=5, pady=10)

        self.prev_btn = ttk.Button(button_frame, text="上一页", command=self.show_prev_page, state="disabled")
        self.prev_btn.pack(side="left", padx=5, pady=5)

        self.next_btn = ttk.Button(button_frame, text="下一页", command=self.show_next_page, state="disabled")
        self.next_btn.pack(side="left", padx=5, pady=5)

    def load_csv_data(self):
        """加载CSV文件数据并自动分类"""
        # 选择多个CSV文件
        file_paths = filedialog.askopenfilenames(
            title="选择流体流动实验CSV文件（需包含流体阻力、离心泵数据）",
            filetypes=[("CSV Files", "*.csv")],
            initialdir="./",
        )

        if not file_paths:
            return

        try:
            # 文件分类字典
            file_dict = {"fluid": None, "pump": None}

            # 根据文件名关键词分类文件
            for path in file_paths:
                filename = os.path.basename(path).lower()
                if "流体阻力" in filename:
                    file_dict["fluid"] = path
                elif "离心泵" in filename:
                    file_dict["pump"] = path

            # 检查是否所有必要文件都已找到
            missing_files = [name for name, path in file_dict.items() if path is None]
            if missing_files:
                messagebox.showerror("错误", f"缺少必要的文件类型: {', '.join(missing_files)}")
                return

            # 存储分类后的文件路径
            self.csv_file_paths = list(file_dict.values())

            # 加载流体阻力数据到表格显示
            df = pd.read_csv(file_dict["fluid"], skiprows=2, header=None)
            raw_data = df.iloc[:, :4].values
            self.update_raw_data_table(raw_data)

            messagebox.showinfo(
                "成功", "文件加载完成，已自动分类:\n" + "\n".join([f"{k}: {v}" for k, v in file_dict.items()])
            )

        except Exception as e:
            messagebox.showerror("错误", f"加载CSV数据失败：{str(e)}")
            logging.error(traceback.format_exc())

    def process_data(self):
        """处理数据"""
        if not self.csv_file_paths:
            messagebox.showwarning("警告", "请先导入CSV数据！")
            return

        try:
            self.show_processing_window()

            # 1. 创建处理器实例并处理数据
            self.processor = Fluid_Flow_Expriment_Processor(self.csv_file_paths)
            self.processor.process_fluid_flow()
            self.processor.process_pump_characteristics()

            # 2. 获取处理后的数据
            self.processed_data = {
                "fluid": self.processor.get_fluid_flow_results(),
                "pump": self.processor.get_pump_characteristics_results(),
            }

            # 3. 更新结果表格
            self.update_results_table()

            # 4. 准备图像路径
            self.images_paths = [
                "./拟合图结果/雷诺数与阻力系数双对数拟合(无插值).png",
                "./拟合图结果/雷诺数与阻力系数双对数拟合(有插值).png",
                "./拟合图结果/离心泵特性曲线及二次拟合.png",
            ]

            self.close_processing_window()
            self.enable_page_buttons()
            messagebox.showinfo("成功", "数据处理完成！")
        except Exception as e:
            self.close_processing_window()
            messagebox.showerror("错误", f"数据处理失败：{str(e)}")
            logging.error(traceback.format_exc())

    def plot_graph(self):
        """绘制图形"""
        if not hasattr(self, "processor") or not self.processor:
            messagebox.showwarning("警告", "请先处理数据！")
            return

        try:
            self.show_processing_window()

            # 1. 调用绘图方法
            self.processor.generate_all_plots()

            # 2. 更新图像路径
            self.images_paths = [
                "./拟合图结果/雷诺数与阻力系数双对数拟合(无插值).png",
                "./拟合图结果/雷诺数与阻力系数双对数拟合(有插值).png",
                "./拟合图结果/离心泵特性曲线及二次拟合.png",
            ]

            # 3. 显示第一张图
            if self.images_paths:
                self.current_page = 0
                self.show_current_page()
                self.enable_page_buttons()

            self.close_processing_window()
            messagebox.showinfo("成功", "图形绘制完成！")
        except Exception as e:
            self.close_processing_window()
            messagebox.showerror("错误", f"绘制图形失败：{str(e)}")
            logging.error(traceback.format_exc())

    # 以下是原有的辅助方法，保持不变
    def show_processing_window(self):
        """显示处理中的窗口"""
        self.processing_window = Toplevel(self.window)
        self.processing_window.title("处理中")
        self.processing_window.geometry("200x100")
        label = ttk.Label(self.processing_window, text="正在处理，请稍候...")
        label.pack(expand=True)
        self.processing_window.grab_set()
        self.processing_window.update()

    def close_processing_window(self):
        """关闭处理中的窗口"""
        if hasattr(self, "processing_window"):
            self.processing_window.grab_release()
            self.processing_window.destroy()

    def update_raw_data_table(self, raw_data=None):
        """更新原始数据表格"""
        self.raw_data_table.clear()
        self.raw_data_table.table["columns"] = self.RAW_COLS
        for col in self.RAW_COLS:
            self.raw_data_table.table.heading(col, text=col)
        if raw_data is not None:
            for idx, row in enumerate(raw_data):
                self.raw_data_table.append([idx + 1, row[0], row[1], row[2]])

    def update_results_table(self):
        """更新结果表格"""
        self.res_data_table.clear()
        self.res_data_table.table["columns"] = self.RESULT_COLS
        for col in self.RESULT_COLS:
            self.res_data_table.table.heading(col, text=col)

        # 流体阻力结果
        fluid_results = self.processed_data["fluid"]
        self.res_data_table.append(
            [
                "流体阻力",
                f"{np.mean(fluid_results['reynolds']):.2f}",
                f"{np.mean(fluid_results['friction_factor']):.2f}",
                "",
                "",
                "",
            ]
        )

        # 离心泵结果
        pump_results = self.processed_data["pump"]
        self.res_data_table.append(
            [
                "离心泵特性",
                "",
                "",
                f"{np.mean(pump_results['head']):.2f}",
                f"{np.mean(pump_results['power']):.2f}",
                f"{np.mean(pump_results['efficiency']):.2f}",
            ]
        )

    def show_current_page(self):
        """显示当前页的图形"""
        self.image_canvas.delete("all")
        if not self.images_paths or self.current_page >= len(self.images_paths):
            return

        try:
            img = Image.open(self.images_paths[self.current_page])
            canvas_width = self.image_canvas.winfo_width()
            canvas_height = self.image_canvas.winfo_height()

            # 保持宽高比缩放
            img_ratio = img.width / img.height
            canvas_ratio = canvas_width / canvas_height

            if canvas_ratio > img_ratio:
                new_height = canvas_height
                new_width = int(new_height * img_ratio)
            else:
                new_width = canvas_width
                new_height = int(new_width / img_ratio)

            img = img.resize((new_width, new_height), Image.Resampling.LANCZOS)
            img_tk = ImageTk.PhotoImage(img)

            # 居中显示
            x_pos = (canvas_width - new_width) // 2
            y_pos = (canvas_height - new_height) // 2

            self.image_canvas.create_image(x_pos, y_pos, image=img_tk, anchor="nw")
            self.image_canvas.image = img_tk

            # 更新页码
            self.page_label.config(text=f"Page {self.current_page + 1}/{len(self.images_paths)}")
        except Exception as e:
            logging.error(f"加载图像失败: {str(e)}")

    def on_resize(self, event):
        """处理画布大小变化"""
        if self.images_paths:
            self.show_current_page()

    def show_prev_page(self):
        """显示上一页"""
        if self.current_page > 0:
            self.current_page -= 1
            self.show_current_page()
        self.enable_page_buttons()  # 新增：翻页后更新按钮状态

    def show_next_page(self):
        """显示下一页"""
        if self.current_page < len(self.images_paths) - 1:
            self.current_page += 1
            self.show_current_page()
        self.enable_page_buttons()  # 新增：翻页后更新按钮状态

    def enable_page_buttons(self):
        """启用/禁用翻页按钮"""
        if not self.images_paths or len(self.images_paths) <= 1:
            self.prev_btn.config(state="disabled")
            self.next_btn.config(state="disabled")
        else:
            # 根据当前页码设置按钮状态
            prev_state = "normal" if self.current_page > 0 else "disabled"
            next_state = "normal" if self.current_page < len(self.images_paths) - 1 else "disabled"
            self.prev_btn.config(state=prev_state)
            self.next_btn.config(state=next_state)

    def close_window(self):
        """关闭窗口"""
        self.window.destroy()


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\heat_transfer_screen.py 的内容:
================================================================================
# heat_transfer_screen.py

# 内部库
import sys
import os

# 动态获取项目根路径
current_script_path = os.path.abspath(__file__)
project_root = os.path.dirname(os.path.dirname(os.path.dirname(current_script_path)))
sys.path.insert(0, project_root)
import logging
import traceback
from tkinter import (
    Label,
    PhotoImage,
    Toplevel,
    messagebox,
    ttk,
    Button,
    filedialog,
    Canvas,
    StringVar,
)
from tkinter import ttk
from PIL import Image, ImageTk
import numpy as np
import pandas as pd

# 配置日志设置
# 保留自己代码的DEBUG日志，过滤第三方库的
logging.basicConfig(level=logging.DEBUG, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s")

# 设置第三方库的日志级别
logging.getLogger("matplotlib").setLevel(logging.WARNING)
logging.getLogger("PIL").setLevel(logging.WARNING)
logging.getLogger("numpy").setLevel(logging.WARNING)
logging.getLogger("pandas").setLevel(logging.WARNING)

# 动态获取项目根路径
current_script_path = os.path.abspath(__file__)
project_root = os.path.dirname(os.path.dirname(os.path.dirname(current_script_path)))
sys.path.insert(0, project_root)

# 导入界面配置和小部件
from gui.screens.utils.config import MAIN_FRAME_CONFIG, SCREEN_CONFIG
from gui.screens.common_widgets.plot_widget import PlotWidget
from gui.screens.common_widgets.table_widget import TableWidget
from gui.screens.common_widgets.text_widget import TextWidget

# 数据处理类
from gui.screens.processors.heat_transfer_experiment_processor import Heat_Transfer_Experiment_Processor


class Heat_Transfer_Screen(ttk.Frame):
    """
    传热实验界面类，包含数据处理、显示和导入功能。
    修改为处理CSV文件而非Excel文件。
    """

    RAW_COLS = ["序号", "Δp孔板/kPa", "t入/°C", "t出/°C"]
    RESULT_COLS = ["组号", "Re", "Pr", "Nu/Pr^0.4"]

    def __init__(self, window):
        super().__init__(window)
        self.window = window
        self.csv_file_paths = None  # 改为存储CSV文件路径列表
        self.processed_data = None
        self.current_page = 0
        self.images_paths = []
        self._init_components()
        self.window.protocol("WM_DELETE_WINDOW", self.close_window)

    def _init_components(self):
        """初始化界面组件"""
        self.main_paned = ttk.PanedWindow(self, orient="horizontal")
        self.main_paned.pack(expand=True, fill="both")

        # 左侧面板
        self.left_frame = ttk.Frame(self.main_paned, width=600)
        self.main_paned.add(self.left_frame, weight=1)
        self._init_left_panel()

        # 右侧面板
        self.right_frame = ttk.Frame(self.main_paned, width=800)
        self.main_paned.add(self.right_frame, weight=2)
        self._init_right_panel()

    def _init_left_panel(self):
        """初始化左侧面板"""
        button_frame = ttk.Frame(self.left_frame)
        button_frame.pack(side="top", fill="x", padx=5, pady=5)

        # 导入数据按钮 - 修改为导入CSV文件
        self.import_data_btn = Button(button_frame, text="导入CSV数据", command=self.load_csv_data)
        self.import_data_btn.pack(side="left", padx=5, pady=5)

        # 处理数据按钮
        self.process_data_btn = Button(button_frame, text="处理数据", command=self.process_data)
        self.process_data_btn.pack(side="left", padx=5, pady=5)

        # 绘制图形按钮
        self.plot_graph_btn = Button(button_frame, text="绘制图形", command=self.plot_graph)
        self.plot_graph_btn.pack(side="left", padx=5, pady=5)

        # 原始数据表格
        self.raw_data_display = ttk.LabelFrame(self.left_frame, text="原始数据")
        self.raw_data_display.pack(pady=10, fill="both", expand=True)
        self.raw_data_table = TableWidget(self.raw_data_display, self.RAW_COLS, widths=[60, 120, 120, 120])
        self.raw_data_table.pack(pady=10, fill="both", expand=True)

        # 结果数据表格
        self.res_data_display = ttk.LabelFrame(self.left_frame, text="计算结果")
        self.res_data_display.pack(pady=10, fill="both", expand=True)
        self.res_data_table = TableWidget(self.res_data_display, self.RESULT_COLS, widths=[60, 120, 120, 120])
        self.res_data_table.pack(pady=10, fill="both", expand=True)

    def _init_right_panel(self):
        """初始化右侧面板"""
        self.right_paned = ttk.PanedWindow(self.right_frame, orient="vertical")
        self.right_paned.pack(fill="both", expand=True)

        # 绘图区域
        self.plot_frame = ttk.Frame(self.right_paned)
        self.right_paned.add(self.plot_frame, weight=1)

        # 图像显示Canvas
        self.image_canvas = Canvas(self.plot_frame)
        self.image_canvas.pack(fill="both", expand=True)
        self.image_canvas.bind("<Configure>", self.on_resize)

        # 页码标签
        self.page_label = ttk.Label(self.right_frame, text="Page 1/1")
        self.page_label.pack(side="top", padx=5, pady=5)

        # 翻页按钮
        button_frame = ttk.Frame(self.right_frame)
        button_frame.pack(side="bottom", fill="x", padx=5, pady=10)

        self.prev_btn = ttk.Button(button_frame, text="上一页", command=self.show_prev_page, state="disabled")
        self.prev_btn.pack(side="left", padx=5, pady=5)

        self.next_btn = ttk.Button(button_frame, text="下一页", command=self.show_next_page, state="disabled")
        self.next_btn.pack(side="left", padx=5, pady=5)

    def load_csv_data(self):
        """加载CSV文件数据并自动分类"""
        # 选择多个CSV文件
        file_paths = filedialog.askopenfilenames(
            title="选择传热实验CSV文件（需包含无强化套管、有强化套管、预处理文件）",
            filetypes=[("CSV Files", "*.csv")],
            initialdir="./",
        )

        if not file_paths:
            return

        try:
            # 文件分类字典
            file_dict = {"无强化套管": None, "有强化套管": None, "预处理_无": None, "预处理_有": None}

            # 根据文件名关键词分类文件
            for path in file_paths:
                filename = os.path.basename(path).lower()
                if "无强化套管" in filename and "预处理" not in filename:
                    file_dict["无强化套管"] = path
                elif "有强化套管" in filename and "预处理" not in filename:
                    file_dict["有强化套管"] = path
                elif "预处理_无" in filename or "数据预处理_无" in filename:
                    file_dict["预处理_无"] = path
                elif "预处理_有" in filename or "数据预处理_有" in filename:
                    file_dict["预处理_有"] = path

            # 检查是否所有必要文件都已找到
            missing_files = [name for name, path in file_dict.items() if path is None]
            if missing_files:
                messagebox.showerror("错误", f"缺少必要的文件类型: {', '.join(missing_files)}")
                return

            # 存储分类后的文件路径
            self.csv_file_paths = list(file_dict.values())

            # 加载无强化套管数据到表格显示
            df = pd.read_csv(file_dict["无强化套管"], header=None)
            raw_data = df.iloc[1:7, 1:4].values
            self.update_raw_data_table(raw_data)

            messagebox.showinfo(
                "成功", "文件加载完成，已自动分类:\n" + "\n".join([f"{k}: {v}" for k, v in file_dict.items()])
            )

        except Exception as e:
            messagebox.showerror("错误", f"加载CSV数据失败：{str(e)}")
            logging.error(traceback.format_exc())

    def process_data(self):
        """处理数据"""
        if not self.csv_file_paths:
            messagebox.showwarning("警告", "请先导入CSV数据！")
            return

        try:
            self.show_processing_window()

            # 1. 创建计算器实例并处理数据
            self.processor = Heat_Transfer_Experiment_Processor(self.csv_file_paths)
            self.processor.calculate()  # 计算数据
            self.processor.store()  # 存储结果

            # 2. 获取处理后的数据
            self.processed_data = self.processor.processed_data

            # 3. 更新结果表格
            self.update_results_table(self.processed_data)

            # 4. 准备图像路径
            self.images_paths = [
                "./传热拟合图结果/无强化套管拟合.png",
                "./传热拟合图结果/有强化套管拟合.png",
                "./传热拟合图结果/传热性能对比.png",
            ]

            self.close_processing_window()
            self.enable_page_buttons()
            messagebox.showinfo("成功", "数据处理完成！")
        except Exception as e:
            self.close_processing_window()
            messagebox.showerror("错误", f"数据处理失败：{str(e)}")
            logging.error(traceback.format_exc())

    def plot_graph(self):
        """绘制图形"""
        if not hasattr(self, "processor") or not self.processor:
            messagebox.showwarning("警告", "请先处理数据！")
            return

        try:
            self.show_processing_window()

            # 1. 调用绘图方法
            self.processor.plot()

            # 2. 压缩结果
            self.processor.compress_results()

            # 3. 更新图像路径
            self.images_paths = [
                "./传热拟合图结果/无强化套管拟合.png",
                "./传热拟合图结果/有强化套管拟合.png",
                "./传热拟合图结果/传热性能对比.png",
            ]

            # 4. 显示第一张图
            if self.images_paths:
                self.current_page = 0
                self.show_current_page()
                self.enable_page_buttons()

            self.close_processing_window()
            messagebox.showinfo("成功", "图形绘制完成！")
        except Exception as e:
            self.close_processing_window()
            messagebox.showerror("错误", f"绘制图形失败：{str(e)}")
            logging.error(traceback.format_exc())

    # 以下是原有的辅助方法，保持不变
    def show_processing_window(self):
        """显示处理中的窗口"""
        self.processing_window = Toplevel(self.window)
        self.processing_window.title("处理中")
        self.processing_window.geometry("200x100")
        label = ttk.Label(self.processing_window, text="正在处理，请稍候...")
        label.pack(expand=True)
        self.processing_window.grab_set()
        self.processing_window.update()

    def close_processing_window(self):
        """关闭处理中的窗口"""
        if hasattr(self, "processing_window"):
            self.processing_window.grab_release()
            self.processing_window.destroy()

    def update_raw_data_table(self, raw_data=None):
        """更新原始数据表格"""
        self.raw_data_table.clear()
        self.raw_data_table.table["columns"] = self.RAW_COLS
        for col in self.RAW_COLS:
            self.raw_data_table.table.heading(col, text=col)
        if raw_data is not None:
            for idx, row in enumerate(raw_data):
                self.raw_data_table.append([idx + 1, row[0], row[1], row[2]])

    def update_results_table(self, processed_data=None):
        """更新结果表格"""
        self.res_data_table.clear()
        self.res_data_table.table["columns"] = self.RESULT_COLS
        for col in self.RESULT_COLS:
            self.res_data_table.table.heading(col, text=col)
        if processed_data is not None:
            for data in processed_data:
                re_mean = np.mean(data["data_for_fit"][:, 0]) if data["data_for_fit"].size > 0 else 0
                pr_mean = np.mean(data["calculated_data"].loc["Pr"]) if "Pr" in data["calculated_data"].index else 0
                nu_pr_mean = np.mean(data["data_for_fit"][:, 1]) if data["data_for_fit"].size > 0 else 0
                self.res_data_table.append(
                    [
                        data["group"],
                        f"{re_mean:.2f}",
                        f"{pr_mean:.2f}",
                        f"{nu_pr_mean:.2f}",
                    ]
                )

    def show_current_page(self):
        """显示当前页的图形"""
        self.image_canvas.delete("all")
        if not self.images_paths or self.current_page >= len(self.images_paths):
            return

        try:
            img = Image.open(self.images_paths[self.current_page])
            canvas_width = self.image_canvas.winfo_width()
            canvas_height = self.image_canvas.winfo_height()

            # 保持宽高比缩放
            img_ratio = img.width / img.height
            canvas_ratio = canvas_width / canvas_height

            if canvas_ratio > img_ratio:
                new_height = canvas_height
                new_width = int(new_height * img_ratio)
            else:
                new_width = canvas_width
                new_height = int(new_width / img_ratio)

            img = img.resize((new_width, new_height), Image.Resampling.LANCZOS)
            img_tk = ImageTk.PhotoImage(img)

            # 居中显示
            x_pos = (canvas_width - new_width) // 2
            y_pos = (canvas_height - new_height) // 2

            self.image_canvas.create_image(x_pos, y_pos, image=img_tk, anchor="nw")
            self.image_canvas.image = img_tk

            # 更新页码
            self.page_label.config(text=f"Page {self.current_page + 1}/{len(self.images_paths)}")
        except Exception as e:
            logging.error(f"加载图像失败: {str(e)}")

    def on_resize(self, event):
        """处理画布大小变化"""
        if self.images_paths:
            self.show_current_page()

    def show_prev_page(self):
        """显示上一页"""
        if self.current_page > 0:
            self.current_page -= 1
            self.show_current_page()

    def show_prev_page(self):
        """显示上一页"""
        if self.current_page > 0:
            self.current_page -= 1
            self.show_current_page()
        self.enable_page_buttons()  # 新增：翻页后更新按钮状态

    def show_next_page(self):
        """显示下一页"""
        if self.current_page < len(self.images_paths) - 1:
            self.current_page += 1
            self.show_current_page()
        self.enable_page_buttons()  # 新增：翻页后更新按钮状态

    def enable_page_buttons(self):
        """启用/禁用翻页按钮"""
        if not self.images_paths or len(self.images_paths) <= 1:
            self.prev_btn.config(state="disabled")
            self.next_btn.config(state="disabled")
        else:
            # 根据当前页码设置按钮状态
            prev_state = "normal" if self.current_page > 0 else "disabled"
            next_state = "normal" if self.current_page < len(self.images_paths) - 1 else "disabled"
            self.prev_btn.config(state=prev_state)
            self.next_btn.config(state=next_state)

    def close_window(self):
        """关闭窗口"""
        self.window.destroy()


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\oxygen_desorption_screen.py 的内容:
================================================================================
# oxygen_desorption_screen.py

# 内部库
import sys
import os
import logging
import traceback
import tkinter as tk
from pathlib import Path
from tkinter import Label, PhotoImage, Toplevel, messagebox, ttk, Button, filedialog, Canvas
from PIL import Image, ImageTk
import pandas as pd

# 配置日志设置
logging.basicConfig(level=logging.DEBUG, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s")
# 设置第三方库的日志级别
logging.getLogger("matplotlib").setLevel(logging.WARNING)
logging.getLogger("PIL").setLevel(logging.WARNING)
logging.getLogger("pandas").setLevel(logging.WARNING)

# 动态获取项目根路径
current_script_path = os.path.abspath(__file__)
project_root = Path(current_script_path).parents[2]  # 向上3级到项目根
sys.path.insert(0, str(project_root))

# 导入界面配置和小部件
from gui.screens.utils.config import MAIN_FRAME_CONFIG, SCREEN_CONFIG

from gui.screens.common_widgets.plot_widget import PlotWidget
from gui.screens.common_widgets.table_widget import TableWidget

# 导入计算器
from gui.screens.calculators.oxygen_desorption_calculator import Oxygen_Desorption_Calculator, Packed_Tower_Calculator

# 导入处理器
from gui.screens.processors.oxygen_desorption_experiment_processor import Oxygen_Desorption_Experiment_Processor


class Oxygen_Desorption_Screen(ttk.Frame):
    """
    氧解吸实验界面类，包含数据处理、显示和可视化功能
    """

    RAW_COLS = ["序号", "水流量(L/h)", "空气流量(m³/h)", "压差(mmH2O)", "入口浓度(mg/L)", "出口浓度(mg/L)", "温度(℃)"]
    RESULT_COLS = ["实验组别", "液相流量(mol/s)", "气相流量(mol/s)", "传质系数Kxa"]

    def __init__(self, window):
        super().__init__(window, **SCREEN_CONFIG)
        self.window = window
        self.file_paths = {}  # 存储四个文件的路径
        self.processed_data = None
        self.current_page = 0
        self.images_paths = []
        self._init_components()
        self.window.protocol("WM_DELETE_WINDOW", self.close_window)

    def _init_components(self):
        """初始化界面组件"""
        self.main_paned = ttk.PanedWindow(self, orient="horizontal")
        self.main_paned.pack(expand=True, fill="both")

        # 左侧面板
        self.left_frame = ttk.Frame(self.main_paned, **MAIN_FRAME_CONFIG)
        self.main_paned.add(self.left_frame, weight=1)

        # 右侧面板
        self.right_frame = ttk.Frame(self.main_paned, **MAIN_FRAME_CONFIG)
        self.main_paned.add(self.right_frame, weight=2)

        self._init_left_panel()
        self._init_right_panel()

    def _init_left_panel(self):
        """初始化左侧操作面板"""
        # 文件选择区域
        file_select_frame = ttk.LabelFrame(self.left_frame, text="数据文件选择")
        file_select_frame.pack(fill="x", padx=5, pady=5)

        # 添加"导入所有文件"按钮
        ttk.Button(file_select_frame, text="导入所有文件", command=self._import_all_files).grid(
            row=0, column=0, columnspan=3, pady=5, sticky="ew"
        )

        # 文件显示区域
        ttk.Label(file_select_frame, text="已选择文件:").grid(row=1, column=0, sticky="w")
        self.file_listbox = tk.Listbox(file_select_frame, height=4, width=40)
        self.file_listbox.grid(row=2, column=0, columnspan=3, padx=5, pady=5, sticky="ew")

        # 操作按钮区域
        button_frame = ttk.Frame(self.left_frame)
        button_frame.pack(fill="x", padx=5, pady=5)

        self.process_btn = ttk.Button(button_frame, text="处理数据", command=self.process_data, state="disabled")
        self.process_btn.pack(side="left", padx=5)

        self.plot_btn = ttk.Button(button_frame, text="生成图表", command=self.plot_graph, state="disabled")
        self.plot_btn.pack(side="left", padx=5)

        # 原始数据表格
        self.raw_data_display = ttk.LabelFrame(self.left_frame, text="原始数据预览")
        self.raw_data_display.pack(fill="both", expand=True, padx=5, pady=5)
        self.raw_data_table = TableWidget(self.raw_data_display, self.RAW_COLS, widths=[10] * len(self.RAW_COLS))
        self.raw_data_table.pack(fill="both", expand=True)

        # 结果数据表格
        self.res_data_display = ttk.LabelFrame(self.left_frame, text="处理结果")
        self.res_data_display.pack(fill="both", expand=True, padx=5, pady=5)
        self.res_data_table = TableWidget(self.res_data_display, self.RESULT_COLS, widths=[15] * len(self.RESULT_COLS))
        self.res_data_table.pack(fill="both", expand=True)

    def _init_right_panel(self):
        """初始化右侧可视化面板"""
        self.right_paned = ttk.PanedWindow(self.right_frame, orient="vertical")
        self.right_paned.pack(fill="both", expand=True)

        # 图像显示区域
        self.image_panel = ttk.Frame(self.right_paned)
        self.right_paned.add(self.image_panel, weight=1)
        self.image_canvas = Canvas(self.image_panel)
        self.image_canvas.pack(fill="both", expand=True)
        self.image_canvas.bind("<Configure>", self.on_resize)

        # 分页控制
        self.page_label = ttk.Label(self.right_frame, text="Page 1/1")
        self.page_label.pack(side="top", padx=5, pady=5)

        # 导航按钮
        nav_frame = ttk.Frame(self.right_frame)
        nav_frame.pack(side="bottom", fill="x", padx=5, pady=10)
        self.prev_btn = ttk.Button(nav_frame, text="上一页", command=self.prev_page, state="disabled")
        self.prev_btn.pack(side="left", padx=5)
        self.next_btn = ttk.Button(nav_frame, text="下一页", command=self.next_page, state="disabled")
        self.next_btn.pack(side="left", padx=5)

    def _import_all_files(self):
        """一次性导入所有需要的文件"""
        file_paths = filedialog.askopenfilenames(
            title="选择氧解吸实验数据文件(请同时选择干填料、湿填料、水流量一定和空气流量一定文件)",
            filetypes=[("CSV文件", "*.csv")],
        )

        if not file_paths:
            return

        # 清空现有文件路径
        self.file_paths = {}
        self.file_listbox.delete(0, tk.END)

        # 根据文件名自动分类文件
        for file_path in file_paths:
            filename = os.path.basename(file_path).lower()

            if "干填料" in filename:
                self.file_paths["dry_packed"] = file_path
                self.file_listbox.insert(tk.END, f"干填料: {file_path}")
            elif "湿填料" in filename:
                self.file_paths["wet_packed"] = file_path
                self.file_listbox.insert(tk.END, f"湿填料: {file_path}")
            elif "水流量一定" in filename:
                self.file_paths["water_constant"] = file_path
                self.file_listbox.insert(tk.END, f"水流量一定: {file_path}")
            elif "空气流量一定" in filename:
                self.file_paths["air_constant"] = file_path
                self.file_listbox.insert(tk.END, f"空气流量一定: {file_path}")

        # 检查是否所有文件都已选择并加载预览
        self._check_files_complete()
        if "dry_packed" in self.file_paths:
            self._load_data_preview(self.file_paths["dry_packed"])

    def _check_files_complete(self):
        """检查是否所有必需文件都已选择"""
        required_files = ["dry_packed", "wet_packed", "water_constant", "air_constant"]
        if all(f in self.file_paths for f in required_files):
            self.process_btn.config(state="normal")
        else:
            self.process_btn.config(state="disabled")
            missing_files = [f for f in required_files if f not in self.file_paths]
            messagebox.showwarning("警告", f"缺少以下文件: {', '.join(missing_files)}\n请确保选择了所有必需文件")

    def _load_data_preview(self, file_path):
        """加载数据预览到表格"""
        try:
            df = pd.read_csv(file_path, header=None)
            # 数据从第3行开始，前两行是标题
            data = df.iloc[2:, 1:7].values  # 取第2列到第7列的数据
            self.update_raw_data_table(data)
        except Exception as e:
            messagebox.showerror("错误", f"数据预览加载失败: {str(e)}")
            logging.error(traceback.format_exc())

    def process_data(self):
        """执行数据处理流程"""
        try:
            self.show_processing_window()

            # 创建实验处理器实例
            self.experiment = Oxygen_Desorption_Experiment_Processor(
                dry_packed_path=self.file_paths["dry_packed"],
                wet_packed_path=self.file_paths["wet_packed"],
                water_constant_path=self.file_paths["water_constant"],
                air_constant_path=self.file_paths["air_constant"],
            )

            # 执行完整分析
            self.experiment.run_full_analysis(compress_results=False)

            # 更新结果表格
            self._update_results()

            # 设置图像路径
            self.images_paths = [
                str(Path(self.experiment.output_dir) / "填料塔性能对比.png"),
                str(Path(self.experiment.output_dir) / "氧解吸传质关联.png"),
            ]

            self.plot_btn.config(state="normal")
            self.close_processing_window()
            messagebox.showinfo("成功", "数据处理完成！")
        except Exception as e:
            self.close_processing_window()
            messagebox.showerror("错误", f"数据处理失败: {str(e)}")
            logging.error(traceback.format_exc())

    def _update_results(self):
        """更新结果表格"""
        self.res_data_table.clear()

        # 填料塔结果（通过Packed_Tower_Calculator获取）
        tower_calculator = Packed_Tower_Calculator(self.experiment.data_loader)
        tower_calculator.analyze_all_files()
        for result in tower_calculator.results:
            self.res_data_table.append([Path(result["csv_file"]).stem, "-", "-", f"拟合类型: {result['fit_type']}"])

        # 氧解吸结果（通过Oxygen_Desorption_Calculator获取）
        oxygen_calculator = Oxygen_Desorption_Calculator(self.experiment.data_loader)
        oxygen_calculator.analyze_all_files()
        for result in oxygen_calculator.results:
            for i in range(len(result["L"])):
                self.res_data_table.append(
                    [
                        f"{Path(result['csv_file']).stem}_{i+1}",
                        f"{result['L'][i]:.4f}",
                        f"{result['G'][i]:.4f}",
                        f"{result['Kxa'][i]:.4f}",
                    ]
                )

    def plot_graph(self):
        """生成并显示图表"""
        if not self.images_paths:
            messagebox.showwarning("警告", "没有可用的图表数据！")
            return

        try:
            self.current_page = 0
            self.show_page()
            self._update_page_controls()
            messagebox.showinfo("成功", "图表生成完成！")
        except Exception as e:
            messagebox.showerror("错误", f"图表显示失败: {str(e)}")
            logging.error(traceback.format_exc())

    def show_processing_window(self):
        """显示处理中提示窗口"""
        self.processing_window = Toplevel(self.window)
        self.processing_window.title("处理中")
        self.processing_window.geometry("300x100")
        Label(self.processing_window, text="数据处理中，请稍候...").pack(expand=True)
        self.processing_window.grab_set()
        self.processing_window.update()

    def close_processing_window(self):
        """关闭处理提示窗口"""
        if hasattr(self, "processing_window"):
            self.processing_window.grab_release()
            self.processing_window.destroy()

    def update_raw_data_table(self, data):
        """更新原始数据表格"""
        self.raw_data_table.clear()
        for idx, row in enumerate(data):
            self.raw_data_table.append([idx + 1] + list(row[:6]))  # 只显示前6列数据

    def on_resize(self, event):
        """调整图像尺寸"""
        if self.images_paths:
            self.show_page()

    def show_page(self):
        """显示当前页图像"""
        self.image_canvas.delete("all")
        if self.current_page < len(self.images_paths):
            try:
                img = Image.open(self.images_paths[self.current_page])
                canvas_width = self.image_canvas.winfo_width()
                canvas_height = self.image_canvas.winfo_height()

                # 保持宽高比缩放
                img_ratio = img.width / img.height
                canvas_ratio = canvas_width / canvas_height

                if canvas_ratio > img_ratio:
                    new_height = canvas_height
                    new_width = int(new_height * img_ratio)
                else:
                    new_width = canvas_width
                    new_height = int(new_width / img_ratio)

                img = img.resize((new_width, new_height), Image.Resampling.LANCZOS)
                img_tk = ImageTk.PhotoImage(img)

                # 居中显示
                x_pos = (canvas_width - new_width) // 2
                y_pos = (canvas_height - new_height) // 2

                self.image_canvas.create_image(x_pos, y_pos, anchor="nw", image=img_tk)
                self.image_canvas.image = img_tk
                self.page_label.config(text=f"Page {self.current_page + 1}/{len(self.images_paths)}")
            except Exception as e:
                logging.error(f"图像加载失败: {str(e)}")

    def prev_page(self):
        """显示上一页"""
        if self.current_page > 0:
            self.current_page -= 1
            self.show_page()
            self._update_page_controls()

    def next_page(self):
        """显示下一页"""
        if self.current_page < len(self.images_paths) - 1:
            self.current_page += 1
            self.show_page()
            self._update_page_controls()

    def _update_page_controls(self):
        """更新分页控制按钮状态"""
        if len(self.images_paths) <= 1:
            self.prev_btn.config(state="disabled")
            self.next_btn.config(state="disabled")
        else:
            self.prev_btn.config(state="normal" if self.current_page > 0 else "disabled")
            self.next_btn.config(state="normal" if self.current_page < len(self.images_paths) - 1 else "disabled")

    def close_window(self):
        """安全关闭窗口"""
        self.window.destroy()


if __name__ == "__main__":
    root = tk.Tk()
    root.title("氧解吸实验数据处理")
    root.geometry("1200x800")
    screen = Oxygen_Desorption_Screen(root)
    screen.pack(expand=True, fill="both")
    root.mainloop()


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\__init__.py 的内容:
================================================================================


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\calculators\distillation_calculator.py 的内容:
================================================================================
# distillation_calculator.py

# 内置库
import sys
import os

# 动态获取路径
current_script_path = os.path.abspath(__file__)
project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(current_script_path))))
sys.path.insert(0, project_root)

import pandas as pd
import numpy as np
import sympy


class Distillation_Calculator:
    """
    精馏塔计算器类，用于计算精馏塔理论板数及相关参数

    主要功能：
    - 读取实验数据文件（CSV格式）
    - 计算进料热状态参数
    - 求解物料平衡方程
    - 计算气液相平衡关系
    - 绘制操作线并计算理论塔板数
    """

    def __init__(self, file_path, R, αm, F, tS, tF):
        """
        初始化精馏计算器

        参数:
        ----------
        file_path : str
            包含实验数据的CSV文件路径
        R : float
            回流比(Reflux Ratio)
        αm : float
            平均相对挥发度
        F : float
            进料流量(mol/h)
        tS : float
            泡点温度(°C)
        tF : float
            进料温度(°C)

        处理流程:
        1. 读取实验数据
        2. 设置物性常数
        3. 计算进料参数
        4. 计算各组分组成
        5. 求解物料平衡
        6. 计算理论塔板数
        """

        # 文件路径
        self.file_path = file_path

        # 从CSV读取实验数据（处理BOM头）
        self.df = pd.read_csv(file_path, header=0, encoding="utf-8-sig")

        # 初始化输入参数
        self.R = R
        self.αm = αm
        self.F = F
        self.tS = tS
        self.tF = tF

        # 初始化结果字典
        self.results = {}  # 添加这一行

        # 执行计算流程
        self.set_constants()
        self.calculate_feed_parameters()
        self.calculate_compositions()
        self.solve_material_balance()
        self.calculate_stages()

        # 将关键结果存储到 results 字典中
        self.results = {
            "回流比": self.R,
            "进料热状态参数": self.q,
            "馏出液组成": self.xD,
            "釜残液组成": self.xW,
            "馏出液流量": self.D,
            "釜残液流量": self.W,
            "理论塔板数": self.NT,
            "各理论板组成": list(zip(self.xn, self.yn)),
            "Q点坐标": (self.xQ, self.yQ),
        }

    def set_constants(self):
        """设置乙醇-水体系的物性常数"""
        # 密度 (g/mL)
        self.ρA, self.ρB = 0.789, 1.0  # 乙醇, 水

        # 比热容 (J/(g·°C))
        self.cA, self.cB = 2.4e3, 4.189e3  # 乙醇, 水

        # 摩尔汽化热 (kJ/kg)
        self.rA, self.rB = 850, 2260  # 乙醇, 水

        # 摩尔质量 (g/mol)
        self.MA, self.MB = 46, 18  # 乙醇, 水

        # 进料摩尔分数 (假设值)
        self.xA, self.xB = 0.1, 0.9  # 乙醇, 水

    def calculate_feed_parameters(self):
        """计算进料热状态参数q"""
        # 计算平均比热容 (J/(mol·°C))
        self.cpm = self.xA * self.cA * self.MA + self.xB * self.cB * self.MB

        # 计算平均汽化热 (J/mol)
        self.rm = self.xA * self.rA * self.MA + self.xB * self.rB * self.MB

        # 计算q值(进料热状态参数)
        if self.tS:  # 如果有泡点温度数据
            self.q = (self.cpm * (self.tS - self.tF) + self.rm) / self.rm
        else:  # 缺省值处理
            self.q = 1.5  # 假设为过热蒸气进料

    def calculate_x_ethanol(self, s):
        """
        将体积分数转换为摩尔分数

        参数:
        s : float
            乙醇体积分数(%)

        返回:
        float
            乙醇摩尔分数
        """
        # 将体积百分比转换为小数
        s /= 100

        # 计算各组分的摩尔数
        moles_A = s * self.ρA / self.MA  # 乙醇摩尔数
        moles_B = (1 - s) * self.ρB / self.MB  # 水摩尔数

        # 计算摩尔分数
        return moles_A / (moles_A + moles_B)

    def calculate_compositions(self):
        """从实验数据计算各关键组分组成"""
        # 全回流条件(R=∞)下的组成
        self.xD_inf = self.calculate_x_ethanol(self.df.loc[0, "20°C酒精度(查表)/°"])
        self.xW_inf = self.calculate_x_ethanol(self.df.loc[1, "20°C酒精度(查表)/°"])

        # 正常回流条件(R=4)下的组成
        self.xD = self.calculate_x_ethanol(self.df.loc[2, "20°C酒精度(查表)/°"])
        self.xW = self.calculate_x_ethanol(self.df.loc[3, "20°C酒精度(查表)/°"])

        # 进料液组成
        self.xF = self.calculate_x_ethanol(self.df.loc[4, "20°C酒精度(查表)/°"])

    def solve_material_balance(self):
        """求解全塔物料平衡方程"""
        if self.R >= 10000:  # 全回流情况处理
            self.D = 0.0  # 馏出液量为0
            self.W = self.F  # 釜残液量等于进料量
            self.L = self.R * self.D  # 实际此时L趋近无穷大
        else:  # 正常情况求解
            # 建立矩阵方程：
            # [1    1  ] [D]   [F]
            # [xD  xW  ] [W] = [F * xF]
            A = sympy.Matrix([[1, 1], [self.xD, self.xW]])
            b = sympy.Matrix([self.F, self.xF * self.F])

            # 解线性方程组
            solution = A.solve(b)
            self.D, self.W = solution[0], solution[1]

            # 计算回流液量
            self.L = self.R * self.D

    def y_e(self, x):
        """
        气液平衡方程(y与x的关系)

        参数:
        x : float
            液相中乙醇的摩尔分数

        返回:
        float
            气相中乙醇的摩尔分数
        """
        return self.αm * x / (1 + (self.αm - 1) * x)

    def x_e(self, y):
        """
        反平衡方程(x与y的关系)

        参数:
        y : float
            气相中乙醇的摩尔分数

        返回:
        float
            液相中乙醇的摩尔分数
        """
        return y / (self.αm - (self.αm - 1) * y)

    def y_np1(self, x):
        """
        精馏段操作线方程

        参数:
        x : float
            第n块板液相组成

        返回:
        float
            第n+1块板气相组成
        """
        return (self.R / (self.R + 1)) * x + self.xD / (self.R + 1)

    def y_mp1(self, x):
        """
        提馏段操作线方程

        参数:
        x : float
            第m块板液相组成

        返回:
        float
            第m+1块板气相组成
        """
        numerator = self.L + self.q * self.F
        denominator = numerator - self.W
        return (numerator / denominator) * x - (self.W * self.xW) / denominator

    def y_q(self, x):
        """
        q线方程(进料方程)

        参数:
        x : float
            液相组成

        返回:
        float
            对应的气相组成
        """
        if self.q == 1:  # 泡点进料
            return x
        else:
            return (self.q / (self.q - 1)) * x - (self.xF / (self.q - 1))

    def calculate_stages(self):
        """通过逐板计算法确定理论塔板数"""
        # 根据回流比选择计算模式
        if self.R >= 10000:  # 全回流模式
            xD = self.xD_inf
            xW = self.xW_inf
        else:  # 正常操作模式
            xD = self.xD
            xW = self.xW

        # 计算两操作线交点Q的坐标
        self.xQ = ((self.R + 1) * self.xF + (self.q - 1) * xD) / (self.R + self.q)
        self.yQ = (self.R * self.xF + self.q * xD) / (self.R + self.q)

        # 初始化迭代变量
        yn = np.array([xD])  # 从塔顶开始计算
        xn = np.array([])  # 存储各板液相组成
        max_iterations = 20  # 防止无限循环
        iteration = 0

        # 逐板计算循环
        while self.x_e(yn[-1]) > xW and iteration < max_iterations:
            iteration += 1

            # 计算当前板的液相组成
            xn = np.append(xn, self.x_e(yn[-1]))

            # 判断使用哪条操作线
            if xn[-1] > self.xQ:  # 在精馏段
                new_y = self.y_np1(xn[-1])
            else:  # 进入提馏段
                new_y = self.y_mp1(xn[-1])

            yn = np.append(yn, new_y)

        # 记录最终液相组成
        xn = np.append(xn, self.x_e(yn[-1]))

        # 计算结果整理
        self.NT = len(xn)  # 总理论板数(包括再沸器)
        self.xn, self.yn = xn, yn  # 保存各板组成

    def save_results(self, filename):
        """将关键结果保存至文本文件"""
        results = []
        results.append("--- Q点坐标 ---")
        results.append(f"xQ: {self.xQ:.4f}")
        results.append(f"yQ: {self.yQ:.4f}")

        results.append("\n--- 各理论板组成 ---")
        for i, (x, y) in enumerate(zip(self.xn, self.yn)):
            results.append(f"第{i}块板: xn = {x:.4f}, yn = {y:.4f}")

        results.append(f"\n总理论板数(包括再沸器): {self.NT}")

        # 确保目录存在
        os.makedirs(os.path.dirname(filename), exist_ok=True)

        with open(filename, "w", encoding="utf-8") as f:  # 直接使用完整路径
            f.write("\n".join(results))


def process_and_save(file_path, R, αm, F, tS, tF, filename):
    """处理并保存结果的辅助函数"""
    try:
        # 创建计算器实例
        calculator = Distillation_Calculator(file_path=file_path, R=R, αm=αm, F=F, tS=tS, tF=tF)

        # 打印关键结果
        print("\n精馏塔计算结果:")
        print(f"回流比 R: {R}")
        print(f"进料热状态参数 q: {calculator.q:.3f}")
        print(f"馏出液组成 xD: {calculator.xD:.4f}")
        print(f"釜残液组成 xW: {calculator.xW:.4f}")
        print(f"馏出液流量 D: {calculator.D:.2f} mol/h")
        print(f"釜残液流量 W: {calculator.W:.2f} mol/h")
        print(f"理论塔板数 NT: {calculator.NT}")

        # 保存详细结果
        results_dir = "./计算结果"
        os.makedirs(results_dir, exist_ok=True)
        results_path = f"{results_dir}/{filename}.txt"
        calculator.save_results(results_path)
        print(f"详细结果已保存至: {results_path}")

        return calculator

    except Exception as e:
        print(f"计算过程中发生错误: {str(e)}")
        return None


if __name__ == "__main__":
    # 设置文件路径 - 相对路径
    file_path = "./csv_data/精馏/精馏原始记录表(非)/Sheet1.csv"

    # 确保输出目录存在
    os.makedirs("./计算结果", exist_ok=True)

    print("=" * 50)
    print("开始精馏塔计算 (两组不同参数)")
    print("=" * 50)

    # 第一组计算: R = 4 时
    print("\n>>> 计算条件: R = 4 <<<")
    calc1 = process_and_save(file_path=file_path, R=4, αm=2.0, F=80, tS=30, tF=26, filename="R_4_结果")

    # 第二组计算: R --> ∞时
    print("\n>>> 计算条件: R --> ∞ <<<")
    calc2 = process_and_save(file_path=file_path, R=10000, αm=2.0, F=80, tS=30, tF=26, filename="R_+∞_结果")

    print("\n计算完成，两组结果已分别保存至计算结果目录")


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\calculators\drying_calculator.py 的内容:
================================================================================
# drying_calculator.py

# 内置库
import sys
import os

# 动态获取路径
current_script_path = os.path.abspath(__file__)
project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(current_script_path))))
sys.path.insert(0, project_root)

import pandas as pd
import numpy as np


class Drying_Calculator:
    def __init__(self, csv_file_paths):
        """初始化计算器，直接传入CSV文件路径列表"""
        self.csv_file_paths = csv_file_paths
        self.results = {}  # 存储计算结果的字典

        # 核心计算参数（通过load_data()初始化）
        self.m_1 = None  # 毛毡润湿前质量 (kg)
        self.m_2 = None  # 毛毡润湿后质量 (kg)
        self.W2 = None  # 托架质量 (kg)
        self.G_prime = None  # 绝干质量 (kg)
        self.ΔP = None  # 压差 (Pa)
        self.τ = None  # 时间序列（小时）
        self.W1 = None  # 总质量序列 (kg)
        self.t = None  # 干球温度序列 (℃)
        self.tw = None  # 湿球温度序列 (℃)

        # 中间计算结果（通过preprocess_data()生成）
        self.G = None  # 湿物料总质量 (kg)
        self.X = None  # 干基含水量 (kg/kg)
        self.τ_bar = None  # 平均时间点 (小时)
        self.X_bar = None  # 平均干基含水量 (kg/kg)
        self.U = None  # 干燥速率 (kg/m²·h)
        self.U_c = None  # 恒定干燥速率 (kg/m²·h)

        # 高级计算结果（通过further_calculations()生成）
        self.α = None  # 传热系数 (kW/m²·K)
        self.V_t0 = None  # 初始体积流量 (m³/s)
        self.V_t = None  # 温度修正后的体积流量 (m³/s)

        # 常数定义
        self.r_tw = 2490  # 水的汽化潜热 (kJ/kg)
        self.S = 2.64e-2  # 干燥面积 (m²)

    def load_data(self):
        """从文件路径列表加载CSV数据"""
        # 根据文件名识别数据文件
        data1_path, data2_path = None, None
        for path in self.csv_file_paths:
            filename = os.path.basename(path).lower()  # 统一小写比较
            if "原始数据1" in filename:
                data1_path = path
            elif "原始数据2" in filename:
                data2_path = path

        if not all([data1_path, data2_path]):
            raise ValueError("未找到原始数据1和原始数据2文件")

        # 读取原始数据1.csv
        df1 = pd.read_csv(data1_path, header=None, skiprows=0)
        data1 = df1.iloc[:, 1].values.astype(float)

        # 提取静态参数
        self.m_1 = data1[0] * 1e-3  # 转换为kg
        self.m_2 = data1[1] * 1e-3
        self.W2 = data1[2] * 1e-3
        self.G_prime = data1[3] * 1e-3
        self.ΔP = data1[4]

        # 读取原始数据2.csv
        df2 = pd.read_csv(data2_path, header=0, skiprows=[1])

        # 提取时间序列数据
        self.τ = df2["累计时间τ/min"].values.astype(float) / 60  # 转换为小时
        self.W1 = df2["总质量W1/g"].values.astype(float) * 1e-3  # 转换为kg
        self.t = df2["干球温度t_dry/℃"].values.astype(float)
        self.tw = df2["湿球温度t_wet/℃"].values.astype(float)

    def preprocess_data(self):
        """执行核心预处理计算"""
        # 计算中间时间点
        self.τ_bar = (self.τ[:-1] + self.τ[1:]) / 2

        # 计算湿物料总质量和干基含水量
        self.G = self.W1 - self.W2
        self.X = (self.G - self.G_prime) / self.G_prime

        # 计算平均含水量和干燥速率
        self.X_bar = (self.X[:-1] + self.X[1:]) / 2
        self.U = -(self.G_prime / self.S) * (np.diff(self.X) / np.diff(self.τ))
        self.U_c = np.mean(self.U[15:])  # 取后15个点的平均值作为恒定速率

        # 存储中间结果
        self.results.update(
            {
                "ans1": np.array([self.G * 1000, self.X]).T.tolist(),
                "ans2": np.array([self.X_bar, self.U]).T.tolist(),
                "τ_bar": self.τ_bar.tolist(),
                "X_bar": self.X_bar.tolist(),
                "U": self.U.tolist(),
                "U_c": float(self.U_c),
            }
        )

    def further_calculations(self):
        """执行高级计算"""
        # 计算传热系数
        self.α = (self.U_c * self.r_tw) / (self.t - self.tw)

        # 流量计算参数
        C_0 = 0.65  # 流量系数
        A_0 = (np.pi * 0.040**2) / 4  # 流通面积 (m²)
        ρ_air = 1.29  # 空气密度 (kg/m³)
        t0 = 25  # 初始温度 (℃)

        # 体积流量计算
        self.V_t0 = C_0 * A_0 * np.sqrt(2 * self.ΔP / ρ_air)
        self.V_t = self.V_t0 * (273 + self.t) / (273 + t0)

        # 存储高级结果
        self.results.update({"α": self.α.tolist(), "V_t0": float(self.V_t0), "V_t": self.V_t.tolist()})

    def run_full_calculation(self):
        """执行完整计算流程"""
        self.load_data()
        self.preprocess_data()
        self.further_calculations()


# 使用示例
if __name__ == "__main__":
    # 初始化计算器时直接传入文件路径列表
    csv_files = [
        "./csv_data/干燥原始数据记录表(非)/原始数据1.csv",
        "./csv_data/干燥原始数据记录表(非)/原始数据2.csv",
    ]

    calculator = Drying_Calculator(csv_files)
    calculator.run_full_calculation()

    # 尝试访问某些计算结果
    print("恒定干燥速率 U_c:", calculator.U_c)
    print("传热系数 α:", calculator.α)
    print("初始体积流量 V_t0:", calculator.V_t0)

    # 获取完整计算结果字典
    full_results = calculator.results
    # print(full_results)


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\calculators\extraction_calculator.py 的内容:
================================================================================
# extraction_calculator.py

import sys
import os

# 动态获取项目根路径
current_script_path = os.path.abspath(__file__)
project_root = os.path.dirname(os.path.dirname(os.path.dirname(current_script_path)))
sys.path.insert(0, project_root)

import logging
import pandas as pd
import numpy as np
from scipy.integrate import trapezoid
from scipy.interpolate import interp1d

# 配置日志设置
logging.basicConfig(level=logging.DEBUG, format="%(asctime)s - %(levelname)s - %(message)s")


class Extraction_Calculator:
    def __init__(self, main_file, distribution_file):
        self.main_file = main_file  # 主数据CSV文件路径
        self.distribution_file = distribution_file  # 分配曲线数据CSV文件路径
        self.results = {}  # 存储处理结果

    def load_data(self):
        """
        加载主数据CSV文件，并进行初步处理。
        """
        # 读取主数据CSV文件
        df1 = pd.read_csv(self.main_file, header=None)
        self.data1 = df1.iloc[1:, 1:].values.astype(float)  # 提取数据部分并转换为浮点数

        # 提取各列数据
        self.n = self.data1[0]  # 实验编号
        self.Vs_S = self.data1[1]  # 溶剂流量 (L/h)
        self.Vs_B = self.data1[2]  # 萃取剂流量 (L/h)
        self.t = self.data1[3]  # 时间
        self.c_NaOH = 0.01  # NaOH浓度
        self.V_to_be_titrated = self.data1[[4, 6, 8], :]  # 待滴定体积
        self.V_NaOH_used = self.data1[[5, 7, 9], :]  # NaOH使用体积

        # 分子量和密度
        self.M_A, self.M_B, self.M_S = 78, 122, 18  # 分子量 (kg/kmol)
        self.ρ_A, self.ρ_B, self.ρ_S = 876.7, 800, 1000  # 密度 (kg/m^3)

    def preprocess_data(self):
        """
        数据预处理，计算相关参数。
        """
        self.Vs_B_rect = self.Vs_S * np.sqrt(self.ρ_S * (7900 - self.ρ_B) / (self.ρ_B * (7900 - self.ρ_S)))

        self.ans1 = (self.c_NaOH * self.V_NaOH_used * 1e-6 * self.M_B) / (self.ρ_B * self.V_to_be_titrated * 1e-6)
        self.X_Rb, self.X_Rt, self.Y_Eb = self.ans1[0], self.ans1[1], self.ans1[2]

        self.B = self.ρ_B * self.Vs_B * 1e-3  # 萃取剂体积 (m^3)
        self.S = self.ρ_S * self.Vs_S * 1e-3  # 溶剂体积 (m^3)
        self.B_rect = self.ρ_B * self.Vs_B_rect * 1e-3  # 校正后的萃取剂体积 (m^3)

        self.ans2 = np.array([self.B, self.S, self.B_rect])
        self.results.update(
            {
                "ans1": self.ans1.tolist(),
                "ans2": self.ans2.tolist(),
                "X_Rb": self.X_Rb.tolist(),
                "X_Rt": self.X_Rt.tolist(),
                "Y_Eb": self.Y_Eb.tolist(),
            }
        )

    def load_distribution_curve_data(self):
        """
        加载分配曲线数据CSV文件。
        """
        df3 = pd.read_csv(self.distribution_file, header=None)
        data3 = df3.iloc[2:, :].values  # 跳过前两行
        self.X3_data = data3[:, 0].astype(float)
        self.Y3_data = data3[:, 1].astype(float)

    def fit_distribution_curve(self):
        """
        拟合分配曲线。
        """
        order = 3  # 多项式阶数
        self.coefficients = np.polyfit(self.X3_data, self.Y3_data, order)
        self.X3_to_fit = np.linspace(min(self.X3_data), max(self.X3_data), 100)
        self.Y_fitted = np.polyval(self.coefficients, self.X3_to_fit)

        self.results.update(
            {
                "X3_data": self.X3_data.tolist(),
                "Y3_data": self.Y3_data.tolist(),
                "coefficients": self.coefficients.tolist(),
                "X3_to_fit": self.X3_to_fit.tolist(),
                "Y_fitted": self.Y_fitted.tolist(),
            }
        )

    def calculate_operating_lines(self):
        """
        计算操作线方程。
        """
        self.k1 = (0 - self.Y_Eb[0]) / (self.X_Rt[0] - self.X_Rb[0])
        self.b1 = self.Y_Eb[0] - self.k1 * self.X_Rb[0]

        self.k2 = (0 - self.Y_Eb[1]) / (self.X_Rt[1] - self.X_Rb[1])
        self.b2 = self.Y_Eb[1] - self.k2 * self.X_Rb[1]

        self.results.update(
            {
                "k1": float(self.k1),
                "b1": float(self.b1),
                "k2": float(self.k2),
                "b2": float(self.b2),
            }
        )

    def perform_graphical_integration(self):
        """
        执行图解积分。
        """
        self.integral_values = []  # 用于存储每个实验组的积分结果
        self.data5_for_graph_integral = []  # 用于存储每组绘图数据

        k = np.array([self.k1, self.k2])
        b = np.array([self.b1, self.b2])

        for i in range(len(self.Y_Eb)):
            Y5_Eb_data = np.linspace(0, self.Y_Eb[i], 20)
            X_Rb_data = (Y5_Eb_data - b[i]) / k[i]
            Y5star_data = np.polyval(self.coefficients, X_Rb_data)
            one_over_Y5star_minus_Y5 = 1 / (Y5star_data - Y5_Eb_data)

            # 将当前实验组的数据存入列表
            self.data5_for_graph_integral.append([Y5_Eb_data, X_Rb_data, Y5star_data, one_over_Y5star_minus_Y5])

            # 插值平滑曲线
            interp_func = interp1d(Y5_Eb_data, one_over_Y5star_minus_Y5, kind="cubic")
            Y5_Eb_data_smooth = np.linspace(Y5_Eb_data.min(), Y5_Eb_data.max(), 40)
            one_over_Y5star_minus_Y5_smooth = interp_func(Y5_Eb_data_smooth)

            # 计算积分并保存
            integral_value = trapezoid(one_over_Y5star_minus_Y5_smooth, Y5_Eb_data_smooth)
            self.integral_values.append(integral_value)

        # 保存积分结果到ans3
        self.ans3 = np.array(self.integral_values)
        self.results["ans3"] = self.ans3.tolist()

    def print_results(self):
        """
        打印计算结果。
        """
        print("\n========== 萃取计算结果 ==========")
        print(f"\n1. 浓度计算结果 (ans1):")
        print(f"X_Rb (萃余相苯甲酸浓度): {self.X_Rb}")
        print(f"X_Rt (萃余相苯甲酸浓度): {self.X_Rt}")
        print(f"Y_Eb (萃取相苯甲酸浓度): {self.Y_Eb}")

        print(f"\n2. 体积计算结果 (ans2):")
        print(f"萃取剂体积 B (m³): {self.B}")
        print(f"溶剂体积 S (m³): {self.S}")
        print(f"校正后的萃取剂体积 B_rect (m³): {self.B_rect}")

        print(f"\n3. 分配曲线拟合系数:")
        print(f"多项式系数: {self.coefficients}")

        print(f"\n4. 操作线参数:")
        print(f"操作线1 - 斜率 k1: {self.k1:.4f}, 截距 b1: {self.b1:.4f}")
        print(f"操作线2 - 斜率 k2: {self.k2:.4f}, 截距 b2: {self.b2:.4f}")

        print(f"\n5. 图解积分结果 (ans3)已计算完成")
        print("\n=================================")

    def run_calculations(self):
        """
        运行完整计算流程。
        """
        self.load_data()
        self.preprocess_data()
        self.load_distribution_curve_data()
        self.fit_distribution_curve()
        self.calculate_operating_lines()
        self.perform_graphical_integration()
        self.print_results()


if __name__ == "__main__":
    main_csv = "./1_原始数据记录.csv"
    distribution_csv = "./3_分配曲线数据集.csv"

    print("开始萃取计算...")
    calculator = Extraction_Calculator(main_csv, distribution_csv)
    calculator.run_calculations()

    # 获取结果示例
    results = calculator.results
    ans1 = calculator.ans1
    ans2 = calculator.ans2
    ans3 = calculator.ans3


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\calculators\filteration_calculator.py 的内容:
================================================================================
import sys
import os
import numpy as np
import pandas as pd
from sklearn.linear_model import LinearRegression


class Filteration_Calculator:
    """
    负责过滤实验数据的计算部分，包括数据加载、拟合、异常值检测等
    """

    def __init__(self, csv_file_path):
        """
        初始化类，接收CSV文件路径，并加载数据
        :param csv_file_path: CSV文件路径
        """
        self.csv_file_path = csv_file_path
        self.data = self.load_csv_data(self.csv_file_path)  # 自动加载数据

        # 初始化用于存储处理后的数据的列表
        self.q_to_refit_lists = []
        self.delta_theta_over_delta_q_to_refit_lists = []
        self.refit_slopes = []
        self.refit_intercepts = []

        # 存储额外的中间变量，用于调试/检查
        self.selected_data = None
        self.data_array = None
        self.deltaV = 9.446e-4
        self.S = 0.0475
        self.deltaQ = self.deltaV / self.S
        self.delta_theta_list = None
        self.delta_q_list = None
        self.delta_theta_over_delta_q_list = None
        self.q_list = None
        self.q_to_fit = None
        self.delta_theta_over_delta_q_to_fit = None
        self.fit_model = None
        self.fit_data = None
        self.fit_slope = None
        self.fit_intercept = None
        self.outliers = None
        self.refit_model = None
        self.filtered_data = None

    def load_csv_data(self, csv_file_path):
        """
        加载CSV文件并进行数据预处理
        :param csv_file_path: CSV文件路径
        :return: 处理后的数据
        """
        data = pd.read_csv(csv_file_path, header=0)
        for col in data.columns:
            data[col] = pd.to_numeric(data[col], errors="coerce")
        data = data.dropna()  # 删除任何含有NaN值的行
        return data

    def perform_linear_fit(self, x, y):
        """
        对数据进行线性拟合
        :param x: 自变量
        :param y: 因变量
        :return: 拟合模型和拟合数据
        """
        fit_data = np.column_stack((x, y))
        model = LinearRegression()
        model.fit(fit_data[:, 0].reshape(-1, 1), fit_data[:, 1])
        return model, fit_data

    def detect_outliers(self, fit_data, threshold=2):
        """
        检测异常值
        :param fit_data: 拟合数据
        :param threshold: 异常值阈值
        :return: 异常值索引
        """
        z_scores = np.abs((fit_data[:, 1] - np.mean(fit_data[:, 1])) / np.std(fit_data[:, 1]))
        outliers = np.where(z_scores > threshold)[0]
        return outliers

    def refit_data_after_outlier_removal(self, fit_data, outliers):
        """
        移除异常值后重新拟合数据
        :param fit_data: 拟合数据 (should be 2D array)
        :param outliers: 异常值索引
        :return: 新的拟合模型和清洗后的数据
        """
        if len(outliers) > 0:
            # 确保异常值不是空的
            filtered_data = np.delete(fit_data, outliers, axis=0)
        else:
            # 如果没有异常值，直接使用原始数据
            filtered_data = fit_data

        if filtered_data.shape[0] == 0:
            raise ValueError("去除异常值后数据为空")

        x = filtered_data[:, 0].reshape(-1, 1)
        y = filtered_data[:, 1]
        model = LinearRegression()
        model.fit(x, y)
        return model, filtered_data

    def process_single_group_data(self, group_index):
        """
        处理单组数据
        :param group_index: 组索引
        :return: 拟合所需的数据
        """
        self.selected_data = self.data.iloc[0:11, 1 + 3 * group_index : 4 + 3 * group_index]
        self.data_array = self.selected_data.values
        self.data_array[:, 0] = self.data_array[:, 0] / 100  # 转换为标准单位

        self.delta_theta_list = np.diff(self.data_array[:, 1])
        self.delta_q_list = np.full(len(self.delta_theta_list), self.deltaQ)
        self.delta_theta_over_delta_q_list = self.delta_theta_list / self.delta_q_list

        self.q_list = np.linspace(0, len(self.delta_theta_list) * self.deltaQ, len(self.delta_theta_list) + 1)
        self.q_to_fit = (self.q_list[:-1] + self.q_list[1:]) / 2
        self.delta_theta_over_delta_q_to_fit = self.delta_theta_over_delta_q_list

        return (
            self.q_to_fit,
            self.delta_theta_over_delta_q_to_fit,
            self.delta_theta_over_delta_q_list,
            self.q_list,
        )

    def process_all_groups(self):
        """
        处理所有组数据并生成拟合数据
        :return: 返回拟合图的q值和Δθ/Δq值
        """
        # 重置列表以保存数据
        self.q_to_refit_lists = []
        self.delta_theta_over_delta_q_to_refit_lists = []
        self.refit_slopes = []
        self.refit_intercepts = []

        for group_index in range(3):
            (
                self.q_to_fit,
                self.delta_theta_over_delta_q_to_fit,
                self.delta_theta_over_delta_q_list,
                self.q_list,
            ) = self.process_single_group_data(group_index)

            self.fit_model, self.fit_data = self.perform_linear_fit(self.q_to_fit, self.delta_theta_over_delta_q_to_fit)
            self.fit_slope = self.fit_model.coef_[0]
            self.fit_intercept = self.fit_model.intercept_

            print(f"第{group_index+1}组数据初拟合结果:")
            print("初拟合斜率:", self.fit_slope)
            print("初拟合截距:", self.fit_intercept)

            self.outliers = self.detect_outliers(self.fit_data)
            if len(self.outliers) > 0:
                self.refit_model, self.filtered_data = self.refit_data_after_outlier_removal(
                    self.fit_data, self.outliers
                )
                self.refit_slope = self.refit_model.coef_[0]
                self.refit_intercept = self.refit_model.intercept_

                print(f"第{group_index+1}组数据排除异常值后重新拟合结果:")
                print("排除异常值后斜率:", self.refit_slope)
                print("排除异常值后截距:", self.refit_intercept)

                self.q_to_refit_lists.append(self.filtered_data[:, 0])
                self.delta_theta_over_delta_q_to_refit_lists.append(self.filtered_data[:, 1])
                self.refit_slopes.append(self.refit_slope)
                self.refit_intercepts.append(self.refit_intercept)

        return (
            self.q_to_refit_lists,
            self.delta_theta_over_delta_q_to_refit_lists,
            self.refit_slopes,
            self.refit_intercepts,
        )


if __name__ == "__main__":
    # 初始化Filteration_Calculator实例，传入文件路径
    filteration_calculator = Filteration_Calculator(r"./过滤原始数据记录表(非).csv")

    # 处理所有组数据并获取结果
    (
        q_to_refit_lists,
        delta_theta_over_delta_q_to_refit_lists,
        refit_slopes,
        refit_intercepts,
    ) = filteration_calculator.process_all_groups()

    # 输出处理后的数据以供验证
    print("q_to_refit_lists:", q_to_refit_lists)
    print(
        "delta_theta_over_delta_q_to_refit_lists:",
        delta_theta_over_delta_q_to_refit_lists,
    )
    print("refit_slopes:", refit_slopes)
    print("refit_intercepts:", refit_intercepts)


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\calculators\fluid_flow_calculator.py 的内容:
================================================================================
# fluid_flow_calculator.py

# 内置库
import sys
import os

# 动态获取路径
current_script_path = os.path.abspath(__file__)
project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(current_script_path))))
sys.path.insert(0, project_root)

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
import os


class Fluid_Flow_Calculator:
    def __init__(self, file_dir):
        self.file_dir = file_dir
        self.ans1 = None
        self.df = None
        self.p = None
        self.log_Re = None
        self.log_λ = None
        self.valid_idx = None

    def process(self):
        """进行流体流动分析，包括计算雷诺数和摩擦系数，并进行双对数拟合"""
        # 已知参数
        d = 0.008  # 管径(m)
        l = 1.70  # 管长(m)
        ρ = 996.5  # 水的密度(kg/m^3)
        g = 9.81  # 重力加速度(m/s^2)
        μ = 8.55e-4  # 粘性系数(Pa·s)

        # 从CSV读取数据（跳过前两行标题和单位行）
        df = pd.read_csv(self.file_dir, skiprows=2, header=None)

        # 处理非数值数据（将非数值转为NaN后填充0）
        df[1] = pd.to_numeric(df[1], errors="coerce").fillna(0)  # Q列
        df[2] = pd.to_numeric(df[2], errors="coerce").fillna(0)  # 直管阻力压降
        df[3] = pd.to_numeric(df[3], errors="coerce").fillna(0)  # mmH2O列

        # 提取数据
        Q = df.iloc[:, 1].values / 3600 / 1000  # 转换L/h → m³/s

        # 构造压降数组（前9个为kPa数据，后10个为mmH2O数据）
        ΔPf = np.concatenate(
            [1000 * df.iloc[:9, 2].values, ρ * g * df.iloc[9:, 3].values / 1000]  # kPa → Pa  # mmH2O → Pa
        )

        # 计算流速(m/s)
        u = Q / (np.pi / 4 * d**2)

        # 计算雷诺数
        Re = (d * u * ρ) / μ

        # 计算摩擦系数（避免除以零）
        valid_u = np.where(u != 0, u, 1e-10)  # 替换零值为极小值
        λ = (2 * d) / (ρ * l) * ΔPf / valid_u**2

        # 双对数拟合（过滤无效值）
        valid_idx = (Re > 0) & (λ > 0)
        log_Re = np.log10(Re[valid_idx])
        log_λ = np.log10(λ[valid_idx])

        degree = 9
        coefficients = np.polyfit(log_Re, log_λ, degree)
        p = np.poly1d(coefficients)

        # 保存结果到实例变量
        self.ans1 = np.column_stack((u, Re, λ))
        self.df = df
        self.p = p
        self.log_Re = log_Re
        self.log_λ = log_λ
        self.valid_idx = valid_idx
        return self.ans1, self.df


class Centrifugal_Pump_Characteristics_Calculator:
    def __init__(self, file_dir):
        self.file_dir = file_dir
        self.ans2 = None
        self.df = None
        self.params_H = None
        self.params_N = None
        self.params_η = None

    @staticmethod
    def quadratic(x, a, b, c):
        return a * x**2 + b * x + c

    def process(self):
        """分析离心泵特性曲线，包括扬程、功率和效率的计算与二次拟合"""
        # 从CSV读取数据（跳过标题行）
        df = pd.read_csv(self.file_dir, skiprows=1, header=None)

        # 处理非数值数据
        for col in [1, 2, 3, 4]:
            df[col] = pd.to_numeric(df[col], errors="coerce").fillna(0)

        # 提取数据
        Q = df.iloc[:, 1].values  # 流量(m³/h)
        p_in = df.iloc[:, 2].values  # 入口压力(MPa)
        p_out = df.iloc[:, 3].values  # 出口压力(MPa)
        N_elc = df.iloc[:, 4].values  # 电机功率(kW)

        # 已知参数
        ρ = 995.7  # 水的密度(kg/m^3)
        g = 9.81  # 重力加速度(m/s²)
        Δz = 0.23  # 高度差(m)
        η_elc = 0.6  # 电机效率

        # 计算扬程（压力单位MPa → Pa）
        H = Δz + ((p_out - p_in) * 1e6) / (ρ * g)

        # 计算有效功率（kW → W）
        N_elc_e = N_elc * η_elc * 1000

        # 计算流体有效功率（Q单位m³/h → m³/s）
        N_e = H * Q / 3600 * ρ * g

        # 计算效率（避免除以零）
        valid_N = np.where(N_elc_e != 0, N_elc_e, 1e-10)
        η = N_e / valid_N

        # 二次拟合
        params_H, _ = curve_fit(self.quadratic, Q, H)
        params_N, _ = curve_fit(self.quadratic, Q, N_elc_e)
        params_η, _ = curve_fit(self.quadratic, Q, η)

        # 保存结果到实例变量
        self.ans2 = np.column_stack((H, N_elc_e, η))
        self.df = df
        self.params_H = params_H
        self.params_N = params_N
        self.params_η = params_η
        return self.ans2, self.df, self.params_H, self.params_N, self.params_η


class Auxiliary:
    def __init__(self, file_paths):
        self.file_paths = file_paths
        self.results = {}

    def identify_file_type(self, file_path):
        """根据文件名识别文件类型"""
        file_name = os.path.basename(file_path)
        if "流体阻力" in file_name:
            return "fluid"
        elif "离心泵" in file_name:
            return "pump"
        else:
            raise ValueError(f"无法识别文件类型: {file_name}")

    def process_files(self):
        """处理所有文件"""
        for file_path in self.file_paths:
            try:
                file_type = self.identify_file_type(file_path)
                if file_type == "fluid":
                    calculator = Fluid_Flow_Calculator(file_path)
                    ans, df = calculator.process()
                    self.results["fluid"] = {"ans": ans, "df": df}
                elif file_type == "pump":
                    calculator = Centrifugal_Pump_Characteristics_Calculator(file_path)
                    ans, df, params_H, params_N, params_η = calculator.process()
                    self.results["pump"] = {
                        "ans": ans,
                        "df": df,
                        "params_H": params_H,
                        "params_N": params_N,
                        "params_η": params_η,
                    }
            except Exception as e:
                print(f"处理文件 {file_path} 时出错: {str(e)}")

    def get_results(self):
        """获取处理结果"""
        return self.results


if __name__ == "__main__":
    # 文件路径列表
    file_paths = [
        "./csv_data/流体/流体原始数据记录表(非)/流体阻力原始数据.csv",
        "./csv_data/流体/流体原始数据记录表(非)/离心泵原始数据.csv",
    ]

    # 确保输出目录存在
    os.makedirs("./拟合图结果", exist_ok=True)

    # 创建Auxiliary实例并处理文件
    processor = Auxiliary(file_paths)
    processor.process_files()

    # 获取结果
    results = processor.get_results()

    # 打印结果字典的键
    print("处理完成，结果字典包含以下键:", results.keys())


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\calculators\heat_transfer_calculator.py 的内容:
================================================================================
import sys
import os

# 动态获取项目根路径
current_script_path = os.path.abspath(__file__)
project_root = os.path.dirname(os.path.dirname(os.path.dirname(current_script_path)))
sys.path.insert(0, project_root)

import numpy as np
import pandas as pd
from scipy.optimize import curve_fit


class Heat_Transfer_Calculator:
    """
    传热计算器类。
    """

    def __init__(self, csv_file_paths):
        """
        初始化函数，加载CSV文件并读取数据集。

        参数:
        csv_file_paths (list): CSV文件路径列表
        """
        self.file_dict = self._categorize_files(csv_file_paths)  # CSV文件路径列表
        self.datasets = self.load_data()  # 加载数据集
        self.results = []  # 存储处理结果

    def _categorize_files(self, paths):
        """根据文件名分类文件"""
        file_dict = {"无强化套管": None, "有强化套管": None, "预处理_无": None, "预处理_有": None}

        for path in paths:
            if "无强化套管" in path and "预处理" not in path:
                file_dict["无强化套管"] = path
            elif "有强化套管" in path and "预处理" not in path:
                file_dict["有强化套管"] = path
            elif "数据预处理_无" in path:
                file_dict["预处理_无"] = path
            elif "数据预处理_有" in path:
                file_dict["预处理_有"] = path

        missing = [k for k, v in file_dict.items() if v is None]
        if missing:
            raise ValueError(f"缺少必要文件: {missing}")
        return file_dict

    def load_data(self):
        datasets = []
        # 按类型读取文件
        for file_type in ["无强化套管", "有强化套管"]:
            file_path = self.file_dict[file_type]
            df = pd.read_csv(file_path, header=None)
            data = np.array(df.iloc[1:7, 1:4].values, dtype=float)
            datasets.append(
                {
                    "Δp_kb": data[:, 0],
                    "t_in": data[:, 1],
                    "t_out": data[:, 2],
                }
            )
        return datasets

    def preprocess_data(self, Δp_kb, t_in, t_out):
        """
        传热数据预处理，计算相关参数并生成原始数据和计算结果表格。

        参数:
        Δp_kb (numpy.ndarray): 孔板压差数据
        t_in (numpy.ndarray): 入口温度数据
        t_out (numpy.ndarray): 出口温度数据

        返回:
        ans_original_data (pd.DataFrame): 原始数据表格
        ans_calculated_data (pd.DataFrame): 计算结果表格
        data_for_fit (numpy.ndarray): 用于拟合的数据
        """
        # 计算过程
        t_w = 98.4  # 壁面温度
        d_o = 0.022  # 外径
        d_i = d_o - 2 * 0.001  # 内径
        l = 1.2  # 长度
        n = 1  # 管数
        C_0 = 0.65  # 流量系数
        S_i = np.pi * l * n * d_i  # 内表面积
        S_o = np.pi * l * n * d_o  # 外表面积
        A_i = (np.pi * d_i**2) / 4  # 内截面积
        A_0 = 2.27 * 10**-4  # 孔板面积
        t_avg = 0.5 * (t_in + t_out)  # 平均温度
        Cp = 1005  # 比热容
        ρ = (t_avg**2) / 10**5 - (4.5 * t_avg) / 10**3 + 1.2916  # 密度
        λ = -(2 * t_avg**2) / 10**8 + (8 * t_avg) / 10**5 + 0.0244  # 导热系数
        μ = (-(2 * t_avg**2) / 10**6 + (5 * t_avg) / 10**3 + 1.7169) / 10**5  # 动力粘度
        Pr = (Cp * μ) / λ  # 普朗特数
        PrZeroFour = Pr**0.4  # 普朗特数的0.4次方
        V_t = 3600 * A_0 * C_0 * np.sqrt((2 * 10**3 * Δp_kb) / ρ)  # 体积流量
        V_xiu = ((t_avg + 273.15) * V_t) / (t_in + 273.15)  # 修正体积流量
        u_m = V_xiu / (3600 * A_i)  # 平均流速
        W_c = (ρ * V_xiu) / 3600  # 质量流量
        Q = Cp * W_c * (t_out - t_in)  # 热流量
        α_i = Q / (t_avg * S_i)  # 内表面换热系数
        Nu_i = (d_i * α_i) / λ  # 努塞尔数
        Re_i = (ρ * d_i * u_m) / μ  # 雷诺数
        NuOverPrZeroFour = Nu_i / Pr**0.4  # 努塞尔数与普朗特数的0.4次方之比
        Δt1 = t_w - t_in  # 温差1
        Δt2 = t_w - t_out  # 温差2
        Δt_m = (Δt2 - Δt1) / (np.log(Δt2) - np.log(Δt1))  # 平均温差
        K_o = Q / (Δt_m * S_o)  # 总传热系数

        # 创建原始数据表格
        ans_original_data = pd.DataFrame(
            {
                "序号": np.arange(1, len(Δp_kb) + 1),
                "Δp孔板/kPa": Δp_kb,
                "t入/°C": t_in,
                "t出/°C": t_out,
            }
        )

        # 创建计算结果表格
        ans_calculated_data = pd.DataFrame(
            {
                "序号": np.arange(1, len(Δp_kb) + 1),
                "Δp": Δp_kb,
                "t入": t_in,
                "t出": t_out,
                "t平": t_avg,
                "ρ": ρ,
                "λ": λ,
                "μ": μ,
                "Pr": Pr,
                "Pr^0.4": PrZeroFour,
                "V_t": V_t,
                "V修": V_xiu,
                "u_m": u_m,
                "W_c": W_c,
                "Q": Q,
                "α_i": α_i,
                "Nu_i": Nu_i,
                "Re_i": Re_i,
                "Nu/Pr^0.4": NuOverPrZeroFour,
                "Δt1": Δt1,
                "Δt2": Δt2,
                "Δt_m": Δt_m,
                "K_o": K_o,
            }
        ).T

        # 准备用于拟合的数据
        data_for_fit = np.array([Re_i, NuOverPrZeroFour]).T

        return ans_original_data, ans_calculated_data, data_for_fit

    def fit_func(self, x, a, b):
        """
        拟合函数，用于曲线拟合。

        参数:
        x (numpy.ndarray): 自变量
        a (float): 拟合参数
        b (float): 拟合参数

        返回:
        numpy.ndarray: 拟合结果
        """
        return a + b * x

    def process_data(self):
        """
        处理数据集，进行数据预处理和曲线拟合。
        """
        for idx, dataset in enumerate(self.datasets):
            Δp_kb = dataset["Δp_kb"]
            t_in = dataset["t_in"]
            t_out = dataset["t_out"]

            ans_original_data, ans_calculated_data, data_for_fit = self.preprocess_data(Δp_kb, t_in, t_out)

            # 检查并过滤掉非正值
            valid_indices = (data_for_fit[:, 0] > 0) & (data_for_fit[:, 1] > 0)
            valid_data = data_for_fit[valid_indices]

            if len(valid_data) > 0:
                ans_params, _ = curve_fit(
                    self.fit_func,
                    np.log10(valid_data[:, 0]),
                    np.log10(valid_data[:, 1]),
                )
            else:
                print(f"警告：数据集 {idx+1} 没有有效的正值用于拟合。")
                ans_params = None

            self.results.append(
                {
                    "original_data": ans_original_data,
                    "calculated_data": ans_calculated_data,
                    "data_for_fit": valid_data,
                    "params": ans_params,
                }
            )

    def print_results(self):
        """
        打印输出results字典的calculated_data键值。
        """
        # 设置显示选项
        pd.set_option("display.max_columns", None)
        pd.set_option("display.max_rows", None)

        for idx, result in enumerate(self.results):
            print(f"数据集 {idx+1} 的计算结果:")
            print(result["calculated_data"])


# 使用示例
if __name__ == "__main__":
    # 定义CSV文件路径列表
    csv_file_paths = [
        "原始数据_无强化套管.csv",
        "原始数据_有强化套管.csv",
        "数据预处理_无强化套管.csv",
        "数据预处理_有强化套管.csv",
    ]

    # 实例化传热计算器
    heat_transfer_calculator = Heat_Transfer_Calculator(csv_file_paths)

    # 加载数据
    datasets = heat_transfer_calculator.load_data()

    # 数据处理
    heat_transfer_calculator.process_data()

    # 打印结果
    heat_transfer_calculator.print_results()


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\calculators\oxygen_desorption_calculator.py 的内容:
================================================================================
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
from scipy.stats import pearsonr
import warnings
from typing import Dict, List, Union
from pathlib import Path

warnings.filterwarnings("ignore")


class Experiment_Data_Loader:
    """数据加载器，负责管理实验数据文件"""

    def __init__(
        self,
        dry_packed: Union[str, Path],
        wet_packed: Union[str, Path],
        water_constant: Union[str, Path],
        air_constant: Union[str, Path],
    ):
        self.file_dict = {
            "干填料.csv": Path(dry_packed),
            "湿填料.csv": Path(wet_packed),
            "水流量一定_空气流量改变.csv": Path(water_constant),
            "空气流量一定_水流量改变.csv": Path(air_constant),
        }

        # 验证所有文件是否存在
        self._validate_files()

    def _validate_files(self):
        """验证所有文件是否存在"""
        missing_files = [name for name, path in self.file_dict.items() if not path.exists()]
        if missing_files:
            raise FileNotFoundError(f"以下文件未找到: {missing_files}")

    def get_file(self, filename: str) -> Path:
        """获取指定文件名的路径"""
        return self.file_dict.get(filename)


# ====================== 填料塔实验 ======================
class Packed_Tower_Calculator:
    def __init__(self, data_loader: Experiment_Data_Loader):
        self.data_loader = data_loader
        self.required_files = ["干填料.csv", "湿填料.csv"]
        self.results = []
        self._init_parameters()
        self._validate_files()

    def _validate_files(self):
        """验证所需文件是否存在"""
        missing_files = [f for f in self.required_files if not self.data_loader.get_file(f).exists()]
        if missing_files:
            raise FileNotFoundError(f"缺少填料塔实验必要文件: {missing_files}")

    def _init_parameters(self):
        self.D = 0.1  # 塔径 (m)
        self.Z = 0.75  # 塔高 (m)
        self.ρ_水 = 1000  # 修正为正确的密度 (kg/m³)
        self.g = 9.8  # 重力加速度 (m/s²)

    @staticmethod
    def linear_fit(x, a, b):
        return a * x + b

    @staticmethod
    def taylor_fit(x, *coefficients):
        return sum(coeff * (x**i) for i, coeff in enumerate(coefficients))

    def analyze_fluid_dynamics(self, csv_file: str, threshold: float = 0.95) -> dict:
        file_path = self.data_loader.get_file(csv_file)
        df = pd.read_csv(file_path, header=None)
        data = df.iloc[2:, 1:].apply(pd.to_numeric, errors="coerce").values

        V_空 = data[:, 0]  # 空塔气速 (m³/h)
        t_空 = data[:, 1]  # 空塔温度 (°C)
        p_空气压力 = data[:, 2] * 1e3  # 转换为Pa
        Δp_全塔_mmH2O = data[:, 4]

        # 计算修正气速
        A = np.pi * (self.D / 2) ** 2
        V_空_修 = V_空 * np.sqrt((1.013e5 / (p_空气压力 + 1.013e5)) * ((t_空 + 273.15) / 298.15))
        u = V_空_修 / A / 3600  # 转换为m/s

        # 计算单位压降 (kPa/m)
        Δp_over_Z = (self.ρ_水 * self.g * Δp_全塔_mmH2O * 1e-3) / (self.Z * 1000)

        # 数据拟合
        corr, _ = pearsonr(u, Δp_over_Z)
        if abs(corr) >= threshold:
            popt, _ = curve_fit(self.linear_fit, u, Δp_over_Z)
            fit_type = "linear"
        else:
            popt, _ = curve_fit(self.taylor_fit, u, Δp_over_Z, p0=[0] * 5)
            fit_type = "taylor"

        return {
            "u": u,
            "delta_p": Δp_over_Z,
            "corr": corr,
            "popt": popt,
            "fit_type": fit_type,
            "csv_file": csv_file,
        }

    def analyze_all_files(self):
        for csv_file in self.required_files:
            try:
                self.results.append(self.analyze_fluid_dynamics(csv_file))
            except Exception as e:
                print(f"分析文件 {csv_file} 时出错: {str(e)}")


# ====================== 氧解吸实验 ======================
class Oxygen_Desorption_Calculator:
    def __init__(self, data_loader: Experiment_Data_Loader):
        self.data_loader = data_loader
        self.required_files = [
            "水流量一定_空气流量改变.csv",
            "空气流量一定_水流量改变.csv",
        ]
        self.results = []
        self._init_parameters()
        self._validate_files()

    def _validate_files(self):
        """验证所需文件是否存在"""
        missing_files = [f for f in self.required_files if not self.data_loader.get_file(f).exists()]
        if missing_files:
            raise FileNotFoundError(f"缺少氧解吸实验必要文件: {missing_files}")

    def _init_parameters(self):
        self.ρ_水 = 1000  # kg/m³
        self.M_H2O = 18e-3  # kg/mol
        self.M_O2 = 32e-3  # kg/mol
        self.D = 0.1  # 塔径 (m)
        self.Z = 0.75  # 塔高 (m)

    @staticmethod
    def oxygen_solubility(t):
        return (-8.5694e-5 * t**2 + 0.07714 * t + 2.56) * 1e9

    def analyze_file(self, csv_file: str) -> dict:
        file_path = self.data_loader.get_file(csv_file)
        df = pd.read_csv(file_path, header=None)
        data = df.iloc[2:, 1:].apply(pd.to_numeric, errors="coerce").values

        V_水 = data[:, 1]  # L/h
        V_空 = data[:, 2]  # m³/h
        ΔP = data[:, 3]  # mmH2O
        c_in = data[:, 5]  # mg/L
        c_out = data[:, 6]  # mg/L
        temp = data[:, 7]  # ℃

        # 修正L的计算：考虑升到立方米的转换
        L = (V_水 * 0.001) * self.ρ_水 / (self.M_H2O * 3600)  # mol/s
        G = V_空 * 1.29 / 29e-3 / 3600  # mol/s
        m = self.oxygen_solubility(temp) / (101325 + 0.5 * ΔP * 9.8)

        # 传质系数计算
        x_in = (c_in * 1e-3 / self.M_O2) / (self.ρ_水 / self.M_H2O + c_in * 1e-3 / self.M_O2)
        x_out = (c_out * 1e-3 / self.M_O2) / (self.ρ_水 / self.M_H2O + c_out * 1e-3 / self.M_O2)
        Kxa = L * (x_in - x_out) / (np.pi * (self.D / 2) ** 2 * self.Z * self._log_mean_delta(x_in, x_out, m))

        return {"L": L, "G": G, "Kxa": Kxa, "csv_file": csv_file}

    def _log_mean_delta(self, x1, x2, m):
        delta1 = x1 - 0.21 / m
        delta2 = x2 - 0.21 / m
        return (delta1 - delta2) / np.log(delta1 / delta2)

    def analyze_all_files(self):
        for csv_file in self.required_files:
            try:
                self.results.append(self.analyze_file(csv_file))
            except Exception as e:
                print(f"分析文件 {csv_file} 时出错: {str(e)}")


# ====================== 主程序 ======================
if __name__ == "__main__":
    # 示例用法 - 替换为您的实际文件路径
    try:
        # 初始化数据加载器，直接传入四个文件的全路径
        data_loader = Experiment_Data_Loader(
            dry_packed="./csv_data/解吸原始记录表(非)/干填料.csv",
            wet_packed="./csv_data/解吸原始记录表(非)/湿填料.csv",
            water_constant="./csv_data/解吸原始记录表(非)/水流量一定_空气流量改变.csv",
            air_constant="./csv_data/解吸原始记录表(非)/空气流量一定_水流量改变.csv",
        )

        # 填料塔实验分析
        tower_calc = Packed_Tower_Calculator(data_loader)
        tower_calc.analyze_all_files()
        print("填料塔实验分析完成")

        # 氧解吸实验分析
        oxygen_calc = Oxygen_Desorption_Calculator(data_loader)
        oxygen_calc.analyze_all_files()
        print("氧解吸实验分析完成")

    except FileNotFoundError as e:
        print(f"错误: {str(e)}")
        print("请确保所有必需文件都存在")
    except Exception as e:
        print(f"发生未知错误: {str(e)}")


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\calculators\__init__.py 的内容:
================================================================================


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\common_screens\base_screen.py 的内容:
================================================================================
class Base_Screen:
    pass


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\common_screens\data_record_screen.py 的内容:
================================================================================
# 内置库
import sys
import os
import time
import csv

# 动态获取路径
current_script_path = os.path.abspath(__file__)
project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(current_script_path))))
sys.path.insert(0, project_root)

from tkinter import ttk
from tkinter import *
import tkinter.filedialog as filedialog
from tkinter.messagebox import showinfo, showwarning

# from tkinter.scrolledtext import ScrolledText

# 根据不同的实验这里为不同的文件，根据不同的实验这里为不同的类
# 这里以过滤实验为例，具体的，应该让用户一开始选择进入的实验界面，用if判断选择
from gui.screens.filteration_screen import Filteration_Screen
from gui.screens.utils.config import (
    DATA_CONFIG,
    DEFAULT_DATA_VALUE,
    FLAT_SUBFRAME_CONFIG,
    MAIN_FRAME_CONFIG,
)
from gui.screens.utils.expserial import EasySerial, getComPorts

from gui.screens.common_widgets.string_entries_widget import StringEntriesWidget


class Data_Record_Screen:
    """
    通用数据记录界面基类
    用于记录从串口接收到的数据并保存到CSV文件或者人为导入csv文件获取数据（不过导入csv文件这一点在各个实验数据处理界面实现即可，
    因为实验数据结构的不同，这里不必实现）。

    相应的组件、按钮、快捷键、分区应该有一些基本的，不像现在是个白板。
    """

    def __init__(self):
        # 通用设置
        self.comport = None
        self.comport_name = None
        self.all_comports = []
        self.start_time = 0
        self.end_time = 0
        self.temp_Delta_t = []
        self.temp_Delta_T = []
        self.temp_file_name = "tempfile.tmp"
        self.temp_file = None
        self.during_measuring = False
        self.csv_data = []
        self.csv_path = ""
        self.t1 = "0.000"
        self.t2 = "0.000"

    def init_states(self):
        """
        初始化状态，禁用一些按钮
        """
        self.button_data_start.config(state="disabled")
        self.button_data_stop.config(state="disabled")
        self.button_save.config(state="disabled")

    def get_comports(self):
        """
        获取可用的串口并选择其中一个打开。
        """
        self.all_comports = getComPorts(select=True, timeout=DATA_CONFIG["port_timeout"])

        # 更新串口选择菜单
        if self.all_comports:
            if self.comport_name.get() not in self.all_comports:
                self.comport_name.set(self.all_comports[0])
            self.change_port(self.comport_name.get())
        else:
            self.comport_name.set("请刷新串口")
            if self.comport:
                self.comport.close()
            self.comport = None

    def change_port(self, event):
        """
        切换串口
        """
        self.comport.close() if self.comport else None
        self.comport = None
        self.comport_name.set(event)
        self.comport = EasySerial(event)

        try:
            # 打开串口并写入临时文件
            self.temp_file = open(
                os.path.join(DATA_CONFIG["py_path"], self.temp_file_name),
                "w",
                encoding="UTF-8",
            )
            self.temp_file.write("time(s),Delta_T(K)\n")
            self.temp_file.flush()
            self.start_time = time.time()
            self.comport.open()
        except Exception as e:
            showwarning("串口错误", f"串口打开失败: {str(e)}")
            self.comport.close()

    def data_start(self):
        """
        开始记录数据
        """
        self.temp_file.close()
        self.temp_file = open(
            os.path.join(DATA_CONFIG["py_path"], self.temp_file_name),
            "w",
            encoding="UTF-8",
        )
        self.temp_file.write("time(s),Delta_T(K)\n")
        self.temp_file.flush()

        self.start_time = time.time()

        # 初始化数据
        self.csv_data = [
            ["time(s)", "Delta_T(K)"],
        ]

        self.during_measuring = True

        self.text_frame.append(f"{time.strftime('%Y.%m.%d %H:%M:%S', time.localtime())} 开始记录\n")
        self.text_frame.see("end")

    def data_end(self):
        """
        停止记录数据
        """
        self.temp_file.write("stop recording\n")
        self.temp_file.flush()
        self.csv_state = False
        self.text_frame.append(f"{time.strftime('%Y.%m.%d %H:%M:%S', time.localtime())} 停止记录\n")
        self.text_frame.see("end")
        self.button_data_stop.config(state="disabled")
        self.button_save.config(state="normal")

    def data_save(self):
        """
        保存数据到CSV文件
        """
        self.csv_path = filedialog.asksaveasfilename(
            title="保存数据",
            initialfile=f"{time.strftime('%Y%m%d%H%M%S', time.localtime())}data.csv",
            filetypes=[("CSV", ".csv")],
        )

        if not self.csv_path:
            return

        with open(self.csv_path, "w", encoding="UTF-8", newline="") as f:
            csv.writer(f).writerows(self.csv_data)

        showinfo(title="提示", message=f"数据成功保存至{self.csv_path}")

        self.text_frame.append(f"{time.strftime('%Y.%m.%d %H:%M:%S', time.localtime())} 数据保存成功\n")
        self.text_frame.see("end")

    def read_comport(self):
        """
        从串口读取数据
        """
        try:
            # 读取串口数据
            Delta_T = self.comport.read()
            self.end_time = time.time()
            Delta_t = self.end_time - self.start_time

            # 将数据写入临时文件和csv文件
            self.temp_file.write(f"{Delta_t:.3f},{Delta_T:.3f}\n")
            self.temp_file.flush()

            self.csv_data.append([f"{Delta_t:.3f}", f"{Delta_T:.3f}"])

            # 更新UI表格
            self.table_frame.append((f"{Delta_t:.3f}", f"{Delta_T:.3f}"))

            # 更新数据存储
            self.temp_Delta_t.append(Delta_t)
            self.temp_Delta_T.append(Delta_T)

            # 绘图更新
            self.plot_frame.clear()
            self.plot_frame.plot(self.temp_Delta_t, self.temp_Delta_T, color="#1F77B4")
            self.plot_frame.show()

        except Exception as e:
            showwarning("串口读取错误", f"串口读取数据失败: {str(e)}")


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\common_screens\__init__.py 的内容:
================================================================================


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\common_widgets\plot_widget.py 的内容:
================================================================================
# plot_widget.py

# 内置库
import sys
import os

# 动态获取路径
current_script_path = os.path.abspath(__file__)
project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(current_script_path))))
sys.path.insert(0, project_root)

from tkinter import ttk
from PIL import Image as pilImage
from PIL import ImageTk
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from gui.screens.utils.config import DATA_CONFIG


class PlotWidget(ttk.Frame):
    def __init__(self, master, xlabel, ylabel, **kwargs):
        """
        Initialize PlotWidget to display Matplotlib chart within the Tkinter GUI.
        :param master: Parent container
        :param xlabel: X-axis label
        :param ylabel: Y-axis label
        :param kwargs: Other Tkinter configuration
        """
        super().__init__(master, **kwargs)
        self.xlabel = xlabel
        self.ylabel = ylabel
        self.figure = Figure(dpi=DATA_CONFIG["window"].winfo_fpixels("1i"))
        self.figure.subplots_adjust(left=0.1, right=0.9, top=0.9, bottom=0.15)
        self.f = self.figure.add_subplot(111)
        self.f.set_xlabel(self.xlabel)
        self.f.set_ylabel(self.ylabel)
        self._set_plot_style()

        # Creating the Canvas for embedding Matplotlib figure in Tkinter
        self.canvas = FigureCanvasTkAgg(self.figure, master=self)
        self.canvas.get_tk_widget().pack(fill="both", expand=True)  # Ensuring canvas fills space
        self.canvas.draw()

        # Binding resize event to adjust the canvas size
        self.bind("<Configure>", self.resize_image)

    def _set_plot_style(self):
        """Set plot style such as axis, ticks, and spine visibility."""
        self.f.tick_params(direction="in")
        for spine in self.f.spines.values():
            spine.set_visible(True)
            spine.set_linewidth(0.5)
        self.f.xaxis.label.set_fontname("SimHei")
        self.f.yaxis.label.set_fontname("SimHei")

    def clear(self):
        """Clear the plot content."""
        self.f.clear()
        self.f.set_xlabel(self.xlabel)
        self.f.set_ylabel(self.ylabel)

    def plot(self, x, y, **kwargs):
        """Plot a line graph on the widget."""
        self.f.plot(x, y, **kwargs)

    def scatter(self, x, y, **kwargs):
        """Plot a scatter plot on the widget."""
        self.f.scatter(x, y, **kwargs)

    def legend(self):
        """Show the legend in the plot."""
        self.f.legend()

    def show(self):
        """Render the plot and display it on the canvas."""
        self.canvas.draw()  # Update the canvas to show the plot

    def fill_between(self, x, y1, y2, **kwargs):
        """Fill the area between two curves on the plot."""
        self.f.fill_between(x, y1, y2, **kwargs)

    def resize_image(self, event):
        """Resize the plot based on the window size."""
        frame_width, frame_height = event.width, event.height
        new_width, new_height = (
            frame_width / self.figure.dpi,
            frame_height / self.figure.dpi,
        )
        self.figure.set_size_inches(new_width, new_height, forward=True)
        self.canvas.draw()  # Redraw after resizing the figure

    def save_fig(self, name):
        """Save the figure as an image file."""
        self.figure.set_size_inches(DATA_CONFIG["width_height_inches"])
        self.figure.savefig(fname=name, dpi=DATA_CONFIG["dpi"])


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\common_widgets\spin_entries_widget.py 的内容:
================================================================================
# spin_entries_widget.py

# 内置库
import sys
import os

# 动态获取路径
current_script_path = os.path.abspath(__file__)
project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(current_script_path))))
sys.path.insert(0, project_root)

from tkinter import ttk, StringVar

# 导入配置和过滤处理类（但是这个不应该只应该是过滤的处理类）
from gui.screens.utils.config import DATA_CONFIG, FLAT_SUBFRAME_CONFIG
from gui.screens.maths.common_maths import find_start_end_point


class SpinEntriesWidget(ttk.Frame):
    """
    起终点集合
    """

    PAIRS = 0

    class SpinEntry(ttk.Frame):
        def __init__(self, master, name, default="0", **kwargs):
            """
            初始化 SpinEntry 控件。
            :param master: 父容器
            :param name: 输入框标签
            :param default: 默认值
            :param kwargs: 其他参数
            """
            super().__init__(master, **kwargs)
            self.name = name
            self.label = ttk.Label(self, text=name)
            self.label.place(relx=0, rely=0, relwidth=0.5, relheight=1)
            self.cached = StringVar()
            self.cached.set(default)
            self.var = StringVar()
            self.var.set(default)

            # 设置Spinbox控件
            self.entry = ttk.Spinbox(
                self,
                textvariable=self.var,
                from_=0,
                to=0,
                increment=1,
                command=self.check_memory,
            )
            self.entry.place(relx=0.5, rely=0, relwidth=0.5, relheight=1)
            self._bind_entry_events()

        def _bind_entry_events(self):
            """绑定焦点事件"""
            self.entry.bind("<FocusIn>", lambda *args: self._bind_return())
            self.entry.bind("<FocusOut>", lambda *args: self._unbind_return())

        def _bind_return(self):
            """绑定回车事件"""
            self.bind("<Return>", self.check_memory)

        def _unbind_return(self):
            """解绑回车事件"""
            self.unbind("<Return>")
            self.check_memory()

        def check_memory(self):
            """检查内存中的值是否有效并更新"""
            if not self.var.get().isdigit():
                self.var.set(self.cached.get())
            elif hasattr(DATA_CONFIG["screen"], "spinEntries") and not DATA_CONFIG["screen"].spinEntries.check_memory():
                self.var.set(self.cached.get())
            else:
                self.cached.set(self.var.get())
                DATA_CONFIG["screen"].change_entry()
                DATA_CONFIG["screen"].calc_regression()
                DATA_CONFIG["screen"].plot_regression()
                DATA_CONFIG["screen"].plot_frame.show()

        def set_state(self, state):
            """设置控件状态"""
            self.entry.config(state=state)

        def set_var(self, val):
            """设置变量的值"""
            self.var.set(val)
            self.cached.set(val)

        def set_from_to(self, from_, to):
            """设置Spinbox的上下限"""
            self.entry.config(from_=from_, to=to)

    def __init__(self, master, pairs, **kwargs):
        """
        初始化 SpinEntriesWidget 控件。
        :param master: 父容器
        :param pairs: 配对数
        :param kwargs: 其他参数
        """
        super().__init__(master, **kwargs)
        self.entries = []
        self.entries_table = {}
        self._create_spin_entries(pairs)
        self._create_buttons(pairs)

    def _create_spin_entries(self, pairs):
        """创建起始和终止点输入框"""
        for i in range(pairs):
            row_frame = ttk.Frame(self)
            row_frame.place(relx=0, rely=i * 0.25, relwidth=1, relheight=0.25)
            self.entries.append(self.SpinEntry(row_frame, f"Start {i + 1}"))
            self.entries[-1].place(relx=0, rely=0, relwidth=0.5, relheight=1)
            self.entries.append(self.SpinEntry(row_frame, f"End {i + 1}"))
            self.entries[-1].place(relx=0.5, rely=0, relwidth=0.5, relheight=1)

        # 将entries添加到字典
        for entry in self.entries:
            self.entries_table[entry.name] = entry

    def _create_buttons(self, pairs):
        """创建重置和计算按钮"""
        buttons = ttk.Frame(self)
        buttons.place(relx=0, rely=pairs * 0.25, relwidth=1, relheight=0.25)
        button_left = ttk.Frame(buttons, **FLAT_SUBFRAME_CONFIG)
        button_left.place(relx=0, rely=0, relwidth=0.5, relheight=1)
        button_right = ttk.Frame(buttons, **FLAT_SUBFRAME_CONFIG)
        button_right.place(relx=0.5, rely=0, relwidth=0.5, relheight=1)

        self.button_remake = ttk.Button(button_left, text="重置(Ctrl-Z)", command=self.remake_file)
        self.button_integrate = ttk.Button(button_right, text="计算(Ctrl-D)", command=self.calc)
        self.button_remake.place(relx=0, rely=0, relwidth=1, relheight=1)
        self.button_integrate.place(relx=0, rely=0, relwidth=1, relheight=1)

    def gbl_buttons(self):
        """设置全局按钮"""
        DATA_CONFIG["screen"].button_remake = self.button_remake
        DATA_CONFIG["screen"].button_integrate = self.button_integrate

    def check_memory(self):
        """检查输入值是否合法"""
        if int(self.entries[0].var.get()) < 0:
            return False
        if "csv_len" in DATA_CONFIG and DATA_CONFIG["csv_len"] != -1:
            if DATA_CONFIG["csv_len"] <= int(self.entries[-1].var.get()):
                return False
        for i in range(1, len(self.entries)):
            if int(self.entries[i - 1].var.get()) >= int(self.entries[i].var.get()):
                return False
        return True

    def dump(self):
        """返回所有条目的值"""
        return {entry.name: int(entry.cached.get()) for entry in self.entries}

    def set_var(self, key, value):
        """设置特定条目的值"""
        self.entries_table[key].set_var(value)

    def set_states(self, state):
        """设置所有条目的状态"""
        for entry in self.entries:
            entry.set_state(state)

    def set_from_to(self, name, from_, to):
        """设置条目的上下限"""
        self.entries_table[name].set_from_to(from_, to)

    def remake_file(self):
        """重置文件数据并进行计算"""

        # 调用maths_filteration中的函数，获取起点和终点列表
        # 该函数基于传入的CSV数据、模式、时间范围和标准限制计算数据的起点和终点位置
        self.start_end_points_list = find_start_end_point(
            DATA_CONFIG["csv"],  # CSV数据
            DATA_CONFIG["mode"].get(),  # 获取当前模式
            DATA_CONFIG["time_lower_limit"],  # 时间下限
            DATA_CONFIG["time_upper_limit"],  # 时间上限
            DATA_CONFIG["std_limit"],  # 标准差限制
        )

        # 如果未找到有效的起点和终点数据，则返回
        if self.start_end_points_list is None:
            return

        # 初始化一个空字典，用于存储起点和终点的映射关系
        self.start_end_points_dict = {}

        # 将该字典存储到全局配置中，方便其他地方访问
        DATA_CONFIG["screen"].start_end_points_dict = self.start_end_points_dict

        # 遍历起点和终点的列表，将它们存储到字典中
        # 如果索引是偶数则是“Start”，奇数是“End”
        for i, point in enumerate(self.start_end_points_list):
            self.start_end_points_dict[f"{'End' if i & 1 else 'Start'} {(i >> 1) + 1}"] = (  # 使用位运算计算每组的编号
                point
            )

        # 更新起点和终点的数据
        self._update_start_end_points()

        # 线性回归计算
        # 触发界面更新，进行回归分析
        DATA_CONFIG["screen"].change_entry()  # 更新输入框内容
        DATA_CONFIG["screen"].calc_regression()  # 进行回归计算
        DATA_CONFIG["screen"].plot_regression()  # 绘制回归结果
        DATA_CONFIG["screen"].plot_frame.show()  # 显示图表

    def _update_start_end_points(self):
        """更新起终点字典"""
        for i in range(self.PAIRS + 1):
            if f"End {i}" not in self.start_end_points_dict:
                self.start_end_points_dict[f"End {i}"] = self._calculate_end(i)
            if f"Start {i + 1}" not in self.start_end_points_dict:
                self.start_end_points_dict[f"Start {i + 1}"] = self._calculate_start(i)

        for i in range(1, self.PAIRS + 1):
            self.set_var(f"Start {i}", str(self.start_end_points_dict[f"Start {i}"]))
            self.set_var(f"End {i}", str(self.start_end_points_dict[f"End {i}"]))
            self.set_from_to(
                f"Start {i}",
                self.start_end_points_dict[f"End {i-1}"] + 1,
                self.start_end_points_dict[f"End {i}"] - 1,
            )
            self.set_from_to(
                f"End {i}",
                self.start_end_points_dict[f"Start {i}"] + 1,
                self.start_end_points_dict[f"Start {i + 1}"] - 1,
            )

        # 解锁按钮
        self.button_remake.config(state="normal")
        self.button_integrate.config(state="normal")

    def _calculate_end(self, i):
        """计算终点"""
        if i == 0:
            return -1
        elif i == self.PAIRS:
            return DATA_CONFIG["csv_len"] - 1
        else:
            return int(DATA_CONFIG["csv_len"] * (i * 2 - 1) / (self.PAIRS * 2 - 1))

    def _calculate_start(self, i):
        """计算起点"""
        if i == self.PAIRS:
            return DATA_CONFIG["csv_len"]
        else:
            return int(DATA_CONFIG["csv_len"] * (i * 2) / (self.PAIRS * 2 - 1))

    def calc(self):
        """积分与其他值计算"""
        DATA_CONFIG["screen"].calc_integration()
        DATA_CONFIG["screen"].plot_regression()
        DATA_CONFIG["screen"].plot_integration()
        DATA_CONFIG["screen"].plot_frame.show()
        DATA_CONFIG["screen"].calc_result()


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\common_widgets\string_entries_widget.py 的内容:
================================================================================
# string_entries_widget.py

# 内置库
import sys
import os

# 动态获取路径
current_script_path = os.path.abspath(__file__)
project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(current_script_path))))
sys.path.insert(0, project_root)

import re

from tkinter import ttk, StringVar

# 导入配置
from gui.screens.utils.config import ENTRY_LABEL_CONFIG, DATA_CONFIG


class StringEntriesWidget(ttk.Frame):
    """
    参数集合
    """

    class CachedStringEntryWidget(ttk.Frame):
        def __init__(self, master, name, default="", text=None, **kwargs):
            super().__init__(master, **kwargs)
            self.name = name
            self.text = name if text is None else text
            self.label = ttk.Label(self, text=self.text, **ENTRY_LABEL_CONFIG)
            self.label.place(relx=0, rely=0, relwidth=0.5, relheight=1)

            default = "0" if default is None else default
            self.cached = StringVar(value=default)
            self.var = StringVar(value=default)

            self.entry = ttk.Entry(self, textvariable=self.var)
            self._bind_focus_events()

            self.entry.place(relx=0.5, rely=0, relwidth=0.5, relheight=1)

        def _bind_focus_events(self):
            """绑定输入框的焦点事件"""
            self.entry.bind("<FocusIn>", lambda *args: self._bind_return())
            self.entry.bind("<FocusOut>", lambda *args: self._unbind_return())

        def _bind_return(self):
            """回车事件绑定"""
            self.bind("<Return>", self.check_memory)

        def _unbind_return(self):
            """解绑回车事件"""
            self.unbind("<Return>")
            self.check_memory()

        def check_memory(self):
            """检查输入框的值是否合法"""

            def is_number(s):
                try:
                    float(s)
                    return True
                except ValueError:
                    return False

            def format_input(memory: StringVar, realtime: StringVar):
                """格式化输入框的内容，保留数字和算式"""
                # 保留数字、小数点和四则运算符
                realtime.set(re.sub(r"[^\d+*/().-]+", "", realtime.get()))

                # 如果输入与原先不同
                if realtime.get() != memory.get():
                    # 如果不是数字，则判断是否为合法的数学算式
                    if not is_number(realtime.get()):
                        try:
                            realtime.set(str(eval(realtime.get())))
                            if float(realtime.get()) == float(memory.get()):
                                realtime.set(memory.get())
                            else:
                                memory.set(realtime.get())
                                self.master.change()
                        except:
                            realtime.set(memory.get())
                    else:
                        memory.set(realtime.get())
                        if self.name not in (
                            "dissolution_heat(kJ)",
                            "constant(J/K)",
                            "combustion_heat(J/g)",
                        ):
                            DATA_CONFIG["screen"].change_entry()

            # 调用格式化函数
            format_input(self.cached, self.var)

        def set_state(self, state):
            """设置输入框的状态"""
            self.entry.config(state=state)

        def set_var(self, value):
            """设置变量的值"""
            self.var.set(value)
            self.cached.set(value)

    def __init__(
        self, master, names: list, defaults: dict = {}, dependences=[], texts: dict = {}, cols: int = 2, **kwargs
    ):
        super().__init__(master, **kwargs)
        self.entries = [
            self.CachedStringEntryWidget(self, name, default=defaults.get(name, ""), text=texts.get(name, None))
            for name in names
        ]
        self.entries_table = {entry.name: entry for entry in self.entries}

        # 设置依赖关系
        self._setup_dependencies(dependences)

        # 计算行列数
        self._layout_entries(cols)

    def _setup_dependencies(self, dependences):
        """设置依赖关系：更新一个条目时触发另一个条目的变化"""

        def trace_factory(affected, func, args):
            def trace_template(*_):
                res = func(*[self.entries_table[arg].cached.get() for arg in args])
                self.entries_table[affected].var.set(res)
                self.entries_table[affected].cached.set(res)

            return trace_template

        for traced, affected, func, args in dependences:
            self.entries_table[traced].cached.trace_add("write", trace_factory(affected, func, args))

    def _layout_entries(self, cols):
        """布局输入框组件"""
        rows = len(self.entries) // cols + (1 if len(self.entries) % cols != 0 else 0)
        for i, entry in enumerate(self.entries):
            entry.place(
                relx=(i % cols) / cols,
                rely=(i // cols) / rows,
                relwidth=1 / cols,
                relheight=1 / rows,
            )

    def clear(self):
        """清空所有条目的值"""
        for entry in self.entries:
            entry.set_var("")

    def dump(self):
        """返回所有条目的值"""
        return {entry.name: entry.cached.get() for entry in self.entries}

    def set_states(self, state, names):
        """设置特定条目的状态"""
        for name in names:
            self.entries_table[name].set_state(state)

    def set_all_states(self, state):
        """设置所有条目的状态"""
        for entry in self.entries:
            entry.set_state(state)

    def set_value(self, key, value):
        """设置特定条目的值"""
        if key in self.entries_table:
            self.entries_table[key].set_var(value)


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\common_widgets\table_widget.py 的内容:
================================================================================
# table_widget.py

# 内置库
import sys
import os

# 动态获取路径
current_script_path = os.path.abspath(__file__)
project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(current_script_path))))
sys.path.insert(0, project_root)

from tkinter import ttk


class TableWidget(ttk.Frame):
    """
    表格实现
    """

    def __init__(self, master, cols, widths, **kwargs):
        super().__init__(master, **kwargs)
        self.table = self._create_table(cols, widths)
        self.scrollbar = self._create_scrollbar()

    def _create_table(self, cols, widths):
        """创建表格并设置列和宽度"""
        table = ttk.Treeview(self, show="headings", columns=cols)
        for col, width in zip(cols, widths):
            table.column(col, width=width, anchor="center")
            table.heading(col, text=col)
        table.place(relx=0, rely=0, relwidth=0.95, relheight=1)
        return table

    def _create_scrollbar(self):
        """创建并配置垂直滚动条"""
        scrollbar = ttk.Scrollbar(self, orient="vertical", command=self.table.yview)
        scrollbar.place(relx=0.95, rely=0, relwidth=0.05, relheight=1)
        self.table.configure(yscrollcommand=scrollbar.set)
        return scrollbar

    def append(self, args):
        """向表格中添加一行"""
        self.table.insert("", "end", values=args)
        self.table.yview_moveto(1)  # 滚动到底部

    def clear(self):
        """清空表格内容"""
        self.table.delete(*self.table.get_children())


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\common_widgets\text_widget.py 的内容:
================================================================================
# text_widget.py

# 内置库
import sys
import os

# 动态获取路径
current_script_path = os.path.abspath(__file__)
project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(current_script_path))))
sys.path.insert(0, project_root)

from tkinter import ttk
from tkinter.scrolledtext import ScrolledText


class TextWidget(ttk.Frame):
    """
    信息文本框
    """

    def __init__(self, master, **kwargs):
        super().__init__(master, **kwargs)
        self.textbox = self._create_textbox()

    def _create_textbox(self):
        """创建并配置滚动文本框"""
        textbox = ScrolledText(self)
        textbox.place(relx=0, rely=0, relwidth=1, relheight=1)
        textbox.config(state="disabled")
        return textbox

    def _enable_textbox(self):
        """启用文本框，以便可以修改内容"""
        self.textbox.config(state="normal")

    def _disable_textbox(self):
        """禁用文本框，防止修改内容"""
        self.textbox.config(state="disabled")

    def append(self, s):
        """将文本追加到文本框"""
        self._enable_textbox()
        self.textbox.insert("end", s)
        self._disable_textbox()

    def clear(self):
        """清空文本框内容"""
        self._enable_textbox()
        self.textbox.delete(1.0, "end")
        self._disable_textbox()

    def see(self, pos):
        """滚动到文本框中的指定位置"""
        self.textbox.see(pos)


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\common_widgets\__init__.py 的内容:
================================================================================


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\maths\common_maths.py 的内容:
================================================================================
# common_maths.py

import numpy as np
from scipy import optimize
from scipy.integrate import simps


# 寻找初始起止点
def find_start_end_point(csv, code: str, time_lower_limit: int or float, time_upper_limit: int or float, std_limit: float):  # type: ignore # 建议时间下限30s，时间上限40s，标准差上限0.01
    # 第一列为index，第二列为标准差
    standard_deviation = []
    points = []
    count = 4 if code == "燃烧热" else 6
    platform = True
    start_index = 0
    end_index = 1
    if csv is None:
        return
    while end_index < len(csv):
        time_range = csv[end_index][0] - csv[start_index][0]
        if time_range > time_upper_limit:
            start_index += 1
        elif time_range < time_lower_limit:
            end_index += 1
        else:
            standard_deviation.append([end_index, np.std(csv[start_index:end_index, 1])])
            end_index += 1
    # 寻找起止点
    points.append(0)
    for i in standard_deviation:
        index, std = i
        if std <= std_limit and platform == False:
            points.append(index)
            platform = True
            count -= 1
        elif std > std_limit and platform == True:
            """
            # 会导致非正常数据无法显示图象，暂时删除
            # 排除延后效应的影响
            time_now = csv[index][0]
            while time_now - csv[index][0] < time_lower_limit / 1.0:    # 1.0可调节，越大对延后的校正越弱
                index -= 1
            """
            points.append(index)
            platform = False
            count -= 1
        if count == 2:
            break
    points.append(len(csv) - 1)
    return points


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\maths\__init__.py 的内容:
================================================================================



================================================================================
E:\Chem-Experiment-Process-App\gui\screens\plotters\distillation_plotter.py 的内容:
================================================================================
# distillation_plotter.py

import os
import sys
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.ticker import AutoMinorLocator

# 动态获取路径
current_script_path = os.path.abspath(__file__)
project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(current_script_path))))
sys.path.insert(0, project_root)

# from gui.screens.calculators.distillation_calculator import Distillation_Calculator
from gui.screens.calculators.distillation_calculator import process_and_save


class Distillation_Plotter:
    """
    精馏塔可视化绘图类

    功能：
    - 生成McCabe-Thiele图
    - 可视化理论塔板计算结果
    - 保存可视化结果

    使用方式：
    传入已计算的Distillation_Calculator实例
    """

    def __init__(self, calculator):
        """
        初始化绘图器

        参数:
        calculator : Distillation_Calculator
            已完成计算的精馏计算器实例
        """
        self.calc = calculator

        # 绘图参数配置
        self.figure_size = (10, 8)
        self.dpi = 150
        self.line_styles = {
            "equilibrium": {"linestyle": "--", "color": "blue", "linewidth": 2},
            "operating": {"linestyle": "-", "color": "green", "linewidth": 2},
            "stages": {"linestyle": ":", "color": "purple", "linewidth": 2},
            "q_line": {"linestyle": "-.", "color": "brown", "linewidth": 1.5},
        }

        # 字体配置
        plt.rcParams.update(
            {
                "font.sans-serif": ["SimHei"],  # 设置中文字体
                "axes.unicode_minus": False,  # 正常显示负号
                "font.size": 12,
            }
        )

    def _generate_plot_data(self):
        """生成绘图所需数据"""
        x = np.linspace(0, 1, 100)

        # 各曲线数据
        data = {
            "x": x,
            "y_eq": self.calc.y_e(x),  # 平衡线
            "y_rect": self.calc.y_np1(x),  # 精馏段操作线
            "y_strip": self.calc.y_mp1(x),  # 提馏段操作线
            "y_q": self.calc.y_q(x),  # q线
        }

        # 阶梯图数据
        x_stages = np.array([self.calc.xD])
        y_stages = np.array([self.calc.xD])

        for n, xi in enumerate(self.calc.xn):
            # 垂直线段
            x_stages = np.append(x_stages, xi)
            y_stages = np.append(y_stages, self.calc.yn[n])

            # 水平线段
            x_stages = np.append(x_stages, xi)
            if xi >= self.calc.xQ:
                y_next = self.calc.y_np1(xi)
            else:
                y_next = self.calc.y_mp1(xi)
            y_stages = np.append(y_stages, y_next)

        data.update({"x_stages": x_stages, "y_stages": y_stages})

        return data

    def plot_mccabe_thiele(self, save_path=None, show=True):
        """
        绘制McCabe-Thiele图

        参数:
        save_path : str, optional
            图片保存路径，如果不提供则不保存
        show : bool, optional
            是否显示图表 (默认为True)
        """
        # 准备数据
        data = self._generate_plot_data()

        # 创建图形
        fig, ax = plt.subplots(figsize=self.figure_size, dpi=self.dpi)

        # 绘制主要曲线
        ax.plot(data["x"], data["x"], linestyle="-", color="gray", alpha=0.5, label="对角线")
        ax.plot(data["x"], data["y_eq"], **self.line_styles["equilibrium"], label="平衡线")
        ax.plot(data["x"], data["y_rect"], **self.line_styles["operating"], label="精馏段操作线")
        ax.plot(data["x"], data["y_strip"], **self.line_styles["operating"], label="提馏段操作线")
        ax.plot(data["x"], data["y_q"], **self.line_styles["q_line"], label="q线")

        # 绘制阶梯图
        ax.plot(self.calc.xn, self.calc.yn, marker="+", markersize=10, linestyle="", color="red", label="理论塔板点")
        ax.plot(data["x_stages"], data["y_stages"], **self.line_styles["stages"], label=f"理论塔板 ({self.calc.NT}块)")

        # 标记关键点
        key_points = [
            (self.calc.xD, self.calc.xD, "D (馏出液)", (0.02, -0.05)),
            (self.calc.xW, self.calc.xW, "W (釜残液)", (0.02, 0.02)),
            (self.calc.xQ, self.calc.yQ, "Q (进料点)", (-0.05, 0.02)),
        ]

        for x, y, label, offset in key_points:
            ax.plot(x, y, "ko", markersize=6)
            ax.annotate(
                label,
                xy=(x, y),
                xytext=(x + offset[0], y + offset[1]),
                arrowprops=dict(arrowstyle="->", color="black", linewidth=1),
                bbox=dict(boxstyle="round", alpha=0.2, facecolor="white"),
            )

        # 设置图形属性
        ax.set_xlim(0, 1)
        ax.set_ylim(0, 1)
        ax.set_xlabel("液相摩尔分数 (x)", fontsize=12)
        ax.set_ylabel("气相摩尔分数 (y)", fontsize=12)
        ax.set_title(f"McCabe-Thiele法图解理论板数\n(回流比 R={self.calc.R}, q={self.calc.q:.2f})", fontsize=14, pad=20)

        # 添加网格和刻度
        ax.grid(True, linestyle=":", alpha=0.6)
        ax.xaxis.set_minor_locator(AutoMinorLocator())
        ax.yaxis.set_minor_locator(AutoMinorLocator())

        # 添加理论板数标注
        ax.text(
            0.65,
            0.25,
            f"理论板数: {self.calc.NT}\n"
            f"实际板数: {self.calc.NT - 1}\n"
            f"进料位置: 第{len(self.calc.xn[self.calc.xn > self.calc.xQ])}块",
            bbox=dict(boxstyle="round", alpha=0.2, facecolor="white"),
        )

        # 图例
        ax.legend(loc="upper left", framealpha=0.8)

        # 调整布局
        fig.tight_layout()

        # 保存或显示
        if save_path:
            os.makedirs(os.path.dirname(save_path), exist_ok=True)
            fig.savefig(save_path, dpi=300, bbox_inches="tight")
            print(f"图表已保存至: {save_path}")

        if show:
            plt.show()
        else:
            plt.close(fig)


# 使用示例
if __name__ == "__main__":

    # 1. R -> 4
    calculator = process_and_save(
        file_path="./csv_data/精馏/精馏原始记录表(非)/Sheet1.csv", R=4, αm=2.0, F=80, tS=30, tF=26, filename="R_4_结果"
    )

    if calculator:  # 如果计算成功
        # 创建绘图器并绘图
        plotter = Distillation_Plotter(calculator)
        plotter.plot_mccabe_thiele(save_path="./拟合图结果/R_4_plot.png", show=False)

    # 2. R -> +∞
    calculator = process_and_save(
        file_path="./csv_data/精馏/精馏原始记录表(非)/Sheet1.csv",
        R=10000,
        αm=2.0,
        F=80,
        tS=30,
        tF=26,
        filename="R_+∞_结果",
    )

    if calculator:  # 如果计算成功
        # 创建绘图器并绘图
        plotter = Distillation_Plotter(calculator)
        plotter.plot_mccabe_thiele(save_path="./拟合图结果/R_+∞_plot.png", show=False)


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\plotters\drying_plotter.py 的内容:
================================================================================
# drying_plotter.py

# 内置库
import sys
import os

# 动态获取路径
current_script_path = os.path.abspath(__file__)
project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(current_script_path))))
sys.path.insert(0, project_root)

import zipfile
import pickle

import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.image as mpimg

from pathlib import Path

from gui.screens.calculators.drying_calculator import Drying_Calculator


class Drying_Plotter:
    def __init__(self, calculator):
        """初始化绘图器，需要传入已计算完成的Drying_Calculator实例"""
        if not isinstance(calculator, Drying_Calculator):
            raise TypeError("必须传入Drying_Calculator实例")

        if not calculator.results:
            raise ValueError("计算器尚未执行计算，请先调用run_full_calculation()")

        self.calculator = calculator
        self.setup_plot_style()

    def setup_plot_style(self):
        """绘图样式配置"""
        # plt.style.use("seaborn-v0_8")
        plt.rcParams.update(
            {
                "font.family": ["Microsoft YaHei", "DejaVu Sans"],  # 主字体+回退字体
                "axes.unicode_minus": False,
                "figure.dpi": 150,
                "axes.titlesize": 12,
                "axes.labelsize": 10,
                "xtick.labelsize": 8,
                "ytick.labelsize": 8,
                "mathtext.fontset": "cm",  # 使用Computer Modern数学字体
                "mathtext.default": "regular",
            }
        )

    def _validate_data(self):
        """验证必要绘图数据是否存在"""
        required_attrs = ["τ_bar", "X_bar", "U"]
        missing = [attr for attr in required_attrs if not hasattr(self.calculator, attr)]
        if missing:
            raise AttributeError(f"缺少必要数据: {', '.join(missing)}")

    def plot_drying_curve(self, save_dir="./拟合图结果"):
        """绘制干燥曲线"""
        self._validate_data()
        save_path = Path(save_dir)
        save_path.mkdir(parents=True, exist_ok=True)

        fig, ax = plt.subplots(figsize=(8, 6))
        ax.scatter(
            self.calculator.τ_bar,
            self.calculator.X_bar,
            marker="o",
            color="#FF6B6B",
            edgecolor="w",
            label="实验数据点",
        )
        ax.plot(
            self.calculator.τ_bar,
            self.calculator.X_bar,
            linestyle="--",
            color="#4ECDC4",
            linewidth=2,
            label="拟合曲线",
        )

        ax.set_title("物料干基含水量随时间变化曲线", pad=20)
        ax.set_xlabel(r"干燥时间 $\tau$ (h)", labelpad=10)
        ax.set_ylabel(r"干燥速率 $U\ (\mathrm{kg/m^2 \cdot h})$", labelpad=10)
        ax.grid(True, alpha=0.3)
        ax.legend(frameon=True)

        curve_path = save_path / "drying_curve.png"
        fig.savefig(curve_path, dpi=300, bbox_inches="tight")
        plt.close(fig)
        return str(curve_path)

    def plot_drying_rate_curve(self, save_dir="./拟合图结果"):
        """绘制干燥速率曲线"""
        self._validate_data()
        save_path = Path(save_dir)
        save_path.mkdir(parents=True, exist_ok=True)

        fig, ax = plt.subplots(figsize=(8, 6))
        ax.scatter(
            self.calculator.X_bar,
            self.calculator.U,
            marker="s",
            color="#45B7D1",
            edgecolor="w",
            label="速率数据点",
        )

        # 添加恒定速率参考线
        if self.calculator.U_c is not None:
            ax.axhline(
                y=self.calculator.U_c,
                color="#FF9F43",
                linestyle="--",
                label=f"恒定速率 {self.calculator.U_c:.3f} kg/m²·h",
            )

        ax.set_title("干燥速率曲线", pad=20)
        ax.set_xlabel(r"干基含水量 $X$ (kg/kg 干基)", labelpad=10)
        ax.set_ylabel(r"干燥速率 $U$ (kg/m²·h)", labelpad=10)
        ax.grid(True, alpha=0.3)
        ax.legend(frameon=True)

        rate_path = save_path / "drying_rate_curve.png"
        fig.savefig(rate_path, dpi=300, bbox_inches="tight")
        plt.close(fig)
        return str(rate_path)

    def integrate_images(self, save_dir="./拟合图结果"):
        """
        生成组合对比图（横向排列）
        """
        save_path = Path(save_dir)
        save_path.mkdir(parents=True, exist_ok=True)

        # 生成子图
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))

        # 干燥曲线
        ax1.scatter(self.calculator.τ_bar, self.calculator.X_bar, color="#FF6B6B")
        ax1.plot(self.calculator.τ_bar, self.calculator.X_bar, "#4ECDC4")
        ax1.set_title("干燥曲线")

        # 干燥速率曲线
        ax2.scatter(self.calculator.X_bar, self.calculator.U, color="#45B7D1")
        if self.calculator.U_c:
            ax2.axhline(self.calculator.U_c, color="#FF9F43", linestyle="--")
        ax2.set_title("干燥速率曲线")

        # 统一样式
        for ax in (ax1, ax2):
            ax.grid(True, alpha=0.3)
            ax.tick_params(axis="both", which="major", labelsize=8)

        combined_path = save_path / "combined_plots.png"
        plt.tight_layout()
        fig.savefig(combined_path, dpi=300, bbox_inches="tight")
        plt.close(fig)
        return str(combined_path)

    def compress_results(self, source_dir="./拟合图结果", output_name="拟合结果"):
        """
        生成压缩包
        """
        source_path = Path(source_dir)
        if not source_path.exists():
            raise FileNotFoundError(f"目录不存在: {source_dir}")

        # 直接使用指定的输出名称，不加时间戳
        output_path = Path(f"{output_name}.zip")

        with zipfile.ZipFile(output_path, "w") as zipf:
            for file in source_path.glob("*.png"):
                zipf.write(file, arcname=file.name)

        return str(output_path)

    def serialize_results(self, output_path="干燥实验结果.pkl"):
        """
        带版本控制的序列化
        """
        data = {
            "metadata": {
                "version": "1.1",
                "create_time": pd.Timestamp.now().isoformat(),
                "calculator_type": type(self.calculator).__name__,
            },
            "results": self.calculator.results,
        }

        with open(output_path, "wb") as f:
            pickle.dump(data, f, protocol=pickle.HIGHEST_PROTOCOL)

        return output_path

    def run_full_plotting(self, output_dir="./拟合结果"):
        """完整的绘图流程"""
        results_dir = Path(output_dir)
        results_dir.mkdir(parents=True, exist_ok=True)

        # 生成图表
        self.plot_drying_curve(results_dir)
        self.plot_drying_rate_curve(results_dir)
        combined_path = self.integrate_images(results_dir)

        # 打包结果
        zip_path = self.compress_results(results_dir)
        pkl_path = self.serialize_results(results_dir / "实验数据.pkl")

        return {
            "combined_plot": combined_path,
            "zip_archive": zip_path,
            "serialized_data": pkl_path,
        }


# 使用示例
if __name__ == "__main__":
    csv_files = [
        "./csv_data/干燥原始数据记录表(非)/原始数据1.csv",
        "./csv_data/干燥原始数据记录表(非)/原始数据2.csv",
    ]
    # 执行计算
    calculator = Drying_Calculator(csv_files)
    calculator.run_full_calculation()

    # 初始化绘图器
    plotter = Drying_Plotter(calculator)

    # 运行完整流程
    outputs = plotter.run_full_plotting()

    print("生成结果：")
    print(f"- 组合图表: {outputs['combined_plot']}")
    print(f"- 压缩包: {outputs['zip_archive']}")
    print(f"- 序列化数据: {outputs['serialized_data']}")


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\plotters\extraction_plotter.py 的内容:
================================================================================
# extraction_plotter.py

# 内置库
import sys
import os

# 动态获取路径
current_script_path = os.path.abspath(__file__)
project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(current_script_path))))
sys.path.insert(0, project_root)

import logging
import zipfile
import numpy as np
from scipy.integrate import trapezoid
from scipy.interpolate import interp1d

from gui.screens.calculators.extraction_calculator import Extraction_Calculator

# 配置日志设置
logging.basicConfig(level=logging.DEBUG, format="%(asctime)s - %(levelname)s - %(message)s")

import matplotlib.pyplot as plt


class Extraction_Plotter:
    def __init__(self, calculator):
        self.calculator = calculator
        self._setup_plot_style()
        self.output_dir = "./拟合图结果"

    def _setup_plot_style(self):
        """统一设置专业科研绘图样式"""
        plt.rcParams.update(
            {
                "font.family": [
                    "SimHei",
                    "Microsoft YaHei",
                    "Arial Unicode MS",
                ],  # 字体回退链
                "axes.unicode_minus": False,
                "figure.dpi": 300,  # 印刷级分辨率
                "axes.linewidth": 2,  # 坐标轴线宽
                "grid.alpha": 0.3,  # 网格透明度
                "legend.frameon": False,  # 图例无边框
                "legend.fontsize": 10,  # 图例字号
                "xtick.major.width": 2,  # X轴刻度线宽
                "ytick.major.width": 2,  # Y轴刻度线宽
                "xtick.minor.visible": True,  # 显示次要刻度
                "ytick.minor.visible": True,  # 显示次要刻度
                "figure.facecolor": "white",  # 图表背景色
                "savefig.bbox": "tight",  # 保存时自动裁剪
            }
        )  # 在 Extraction_Plotter 类中修改字体设置方法

    def _setup_plot_style(self):
        """智能配置中文字体，支持跨平台"""
        import matplotlib.font_manager as fm

        # 中文字体优先级列表
        chinese_fonts = [
            "Microsoft YaHei",  # Windows 微软雅黑
            "SimHei",  # Windows 中易黑体
            "WenQuanYi Zen Hei",  # Linux 文泉驿
            "PingFang SC",  # macOS 苹方
            "Source Han Sans SC",  # 思源黑体
        ]

        # 扫描系统所有字体
        system_fonts = {f.name for f in fm.fontManager.ttflist}

        # 选择第一个可用的中文字体
        selected_font = None
        for font in chinese_fonts:
            if font in system_fonts:
                selected_font = font
                break

        # 配置字体参数
        plt.rcParams.update(
            {
                "font.family": "sans-serif",
                "font.sans-serif": [selected_font] if selected_font else [],
                "axes.unicode_minus": False,
                "figure.dpi": 300,
                "axes.linewidth": 2,
                "grid.alpha": 0.3,
                "legend.frameon": False,
                "legend.fontsize": 10,
            }
        )

        # 如果未找到中文字体，显示警告
        if not selected_font:
            import warnings

            warnings.warn(
                "\n\n⚠️ 未检测到系统中文字体！请执行以下操作：\n"
                "Windows用户：安装'微软雅黑'字体\n"
                "Mac用户：终端执行 `brew tap homebrew/cask-fonts && brew install font-wqy-microhei`\n"
                "Linux用户：执行 `sudo apt install fonts-wqy-microhei`"
            )

    def create_output_dir(self):
        """创建输出目录"""
        if not os.path.exists(self.output_dir):
            os.makedirs(self.output_dir)

    def plot_main_curves(self):
        """绘制主分析曲线图"""
        plt.figure(figsize=(10, 8), facecolor="white")

        # 绘制分配曲线
        self._plot_distribution_curve()

        # 绘制操作线
        self._plot_operating_line(0, "操作线1", "#2ca02c")  # 绿色
        self._plot_operating_line(1, "操作线2", "#ff7f0e")  # 橙色

        # 专业图表装饰
        plt.title("分配曲线与操作线分析图", fontsize=14, pad=15)
        plt.xlabel("萃余相浓度 X (kg/kg)", fontsize=12, labelpad=10)
        plt.ylabel("萃取相浓度 Y (kg/kg)", fontsize=12, labelpad=10)
        plt.legend(loc="upper left", fontsize=10)
        plt.grid(True, which="both", linestyle=":", alpha=0.5)
        plt.xlim(0, max(self.calculator.X3_data) * 1.1)
        plt.ylim(0, max(self.calculator.Y3_data) * 1.1)

        # 边框强化
        for spine in plt.gca().spines.values():
            spine.set_linewidth(2)

        self._save_figure("主分析曲线图")

    def _plot_distribution_curve(self):
        """绘制分配曲线元素"""
        plt.scatter(
            self.calculator.X3_data,
            self.calculator.Y3_data,
            c="#9467bd",  # 紫色
            marker="^",
            s=80,
            edgecolor="k",
            linewidth=1,
            label="实验数据点",
            zorder=3,
        )
        plt.plot(
            self.calculator.X3_to_fit,
            self.calculator.Y_fitted,
            color="#1f77b4",  # 蓝色
            lw=2.5,
            label=f"三次多项式拟合 (R²={self._calculate_r_squared():.3f})",
        )

    def _plot_operating_line(self, idx, label, color):
        """专业操作线绘制"""
        X_points = [self.calculator.X_Rb[idx], self.calculator.X_Rt[idx]]
        Y_points = [self.calculator.Y_Eb[idx], 0]

        # 生成直线数据
        X_line = np.linspace(0, X_points[0], 100)
        Y_line = eval(f"self.calculator.k{idx+1}") * X_line + eval(f"self.calculator.b{idx+1}")

        # 绘制元素
        plt.scatter(
            X_points,
            Y_points,
            c=color,
            s=100,
            edgecolors="k",
            linewidth=1,
            zorder=4,
            label=f"{label}端点",
        )
        plt.plot(
            X_line,
            Y_line,
            color=color,
            ls="--",
            lw=2,
            alpha=0.8,
            label=f'{label} ($Y={eval(f"self.calculator.k{idx+1}"):.4f}X+{eval(f"self.calculator.b{idx+1}"):.4f}$)',
        )

    def _calculate_r_squared(self):
        """计算决定系数"""
        y_pred = np.polyval(self.calculator.coefficients, self.calculator.X3_data)
        ss_res = np.sum((self.calculator.Y3_data - y_pred) ** 2)
        ss_tot = np.sum((self.calculator.Y3_data - np.mean(self.calculator.Y3_data)) ** 2)
        return 1 - (ss_res / ss_tot)

    def plot_integration_curves(self):
        """绘制专业级积分曲线"""
        # 直接使用已分组的数据
        grouped_data = self.calculator.data5_for_graph_integral

        for idx, group in enumerate(grouped_data):
            plt.figure(figsize=(10, 6), facecolor="white")

            # 构建数据字典
            data_dict = {
                "Y5_Eb": group[0],
                "X_Rb": group[1],
                "Y5star": group[2],
                "integrand": group[3],
            }

            self._plot_single_integration(data_dict, idx)

            # 专业标注
            plt.title(f"图解积分曲线 - 实验组 {idx+1}", fontsize=12, pad=15)
            plt.xlabel("萃取相浓度 $Y_5$", fontsize=10, labelpad=8)
            plt.ylabel("积分项 $\\frac{1}{Y_5^* - Y_5}$", fontsize=10, labelpad=8)
            plt.grid(True, which="both", linestyle=":", alpha=0.3)

            # 边框强化
            for spine in plt.gca().spines.values():
                spine.set_linewidth(2)

            self._save_figure(f"积分曲线_{idx+1}")

    def _plot_single_integration(self, data, idx):
        """绘制单组积分曲线（科研级样式）"""
        # 插值平滑
        interp_func = interp1d(data["Y5_Eb"], data["integrand"], "cubic")
        Y_smooth = np.linspace(data["Y5_Eb"].min(), data["Y5_Eb"].max(), 100)
        integrand_smooth = interp_func(Y_smooth)

        # 计算积分值
        integral = trapezoid(integrand_smooth, Y_smooth)

        # 专业绘图元素
        plt.fill_between(
            Y_smooth,
            integrand_smooth,
            alpha=0.3,
            color="#8c564b",  # 棕色
            label="积分区域",
        )
        plt.plot(Y_smooth, integrand_smooth, color="#1f77b4", lw=2, label="拟合曲线")  # 蓝色
        plt.scatter(
            data["Y5_Eb"],
            data["integrand"],
            c="#d62728",  # 红色
            s=50,
            edgecolor="k",
            linewidth=0.8,
            label="离散数据点",
            zorder=3,
        )

        # 科研级标注
        plt.text(
            0.95,
            0.85,
            f"积分面积 = {integral:.5f}",
            transform=plt.gca().transAxes,
            ha="right",
            va="top",
            bbox=dict(
                facecolor="white",
                edgecolor="#2f2f2f",
                boxstyle="round,pad=0.3",
                alpha=0.9,
            ),
            fontsize=10,
        )
        plt.legend(loc="upper right", fontsize=9)

    def _save_figure(self, name):
        """保存科研级图表"""
        plt.tight_layout()
        plt.savefig(
            f"{self.output_dir}/{name}.png",
            dpi=300,
            bbox_inches="tight",
            pad_inches=0.1,
        )
        plt.close()

    def package_results(self, zip_file="萃取分析结果.zip"):
        """专业打包方法"""
        with zipfile.ZipFile(zip_file, "w", zipfile.ZIP_DEFLATED) as zipf:
            for root, _, files in os.walk(self.output_dir):
                for file in files:
                    file_path = os.path.join(root, file)
                    zipf.write(file_path, arcname=os.path.relpath(file_path, self.output_dir))


if __name__ == "__main__":
    # 文件路径
    main_csv = "./1_原始数据记录.csv"
    distribution_csv = "./3_分配曲线数据集.csv"

    # 初始化计算器
    calculator = Extraction_Calculator(main_csv, distribution_csv)
    calculator.run_calculations()

    # 初始化绘图器
    plotter = Extraction_Plotter(calculator)
    plotter.create_output_dir()

    # 生成图表
    plotter.plot_main_curves()
    plotter.plot_integration_curves()

    # 打包结果
    plotter.package_results()
    print("处理完成！结果已保存至当前目录")


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\plotters\filteration_plotter.py 的内容:
================================================================================
# filteration_plotter.py

# 内置库
import sys
import os

# 动态获取路径
current_script_path = os.path.abspath(__file__)
project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(current_script_path))))
sys.path.insert(0, project_root)

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
from gui.screens.calculators.filteration_calculator import Filteration_Calculator

# 设置中文字体
plt.rcParams["font.family"] = "SimHei"
plt.rcParams["axes.unicode_minus"] = False
plt.rcParams["figure.dpi"] = 50
plt.rcParams["savefig.dpi"] = 300


class Filteration_Plotter:
    """
    负责生成符合指定风格的图表，保持一致的绘图风格设置
    """

    def __init__(self, csv_file_path):
        """
        初始化绘图类，设置图表的默认样式，并调用计算类进行数据处理
        :param csv_file_path: CSV文件路径
        """
        self.csv_file_path = csv_file_path
        self.calculator = Filteration_Calculator(self.csv_file_path)

        # 获取计算器生成的数据
        (
            self.q_to_refit_lists,
            self.delta_theta_over_delta_q_to_refit_lists,
            self.refit_slopes,
            self.refit_intercepts,
        ) = self.calculator.process_all_groups()

        # 存储来自计算器的所有数据和变量
        self.calculator_data = {
            "data": self.calculator.data,  # 存储加载的CSV数据
            "q_to_refit_lists": self.calculator.q_to_refit_lists,
            "delta_theta_over_delta_q_to_refit_lists": self.calculator.delta_theta_over_delta_q_to_refit_lists,
            "refit_slopes": self.calculator.refit_slopes,
            "refit_intercepts": self.calculator.refit_intercepts,
            "selected_data": self.calculator.selected_data,
            "data_array": self.calculator.data_array,
            "deltaV": self.calculator.deltaV,
            "S": self.calculator.S,
            "deltaQ": self.calculator.deltaQ,
            "delta_theta_list": self.calculator.delta_theta_list,
            "delta_q_list": self.calculator.delta_q_list,
            "delta_theta_over_delta_q_list": self.calculator.delta_theta_over_delta_q_list,
            "q_list": self.calculator.q_list,
            "q_to_fit": self.calculator.q_to_fit,
            "delta_theta_over_delta_q_to_fit": self.calculator.delta_theta_over_delta_q_to_fit,
            "fit_model": self.calculator.fit_model,
            "fit_data": self.calculator.fit_data,
            "fit_slope": self.calculator.fit_slope,
            "fit_intercept": self.calculator.fit_intercept,
            "outliers": self.calculator.outliers,
            "refit_model": self.calculator.refit_model,
            "filtered_data": self.calculator.filtered_data,
        }

        # 图像路径存储变量
        self.images_paths = []

        # 设置图表风格
        plt.rcParams["font.family"] = "SimHei"
        plt.rcParams["axes.unicode_minus"] = False
        plt.rcParams["figure.dpi"] = 50
        plt.rcParams["savefig.dpi"] = 300

        # 存储图表的显示范围配置
        self.plot_ranges_initial = [
            {"x_min": 0, "x_max": 0.200, "y_min": 0, "y_max": 140000},
            {"x_min": 0, "x_max": 0.200, "y_min": 0, "y_max": 25000},
            {"x_min": 0, "x_max": 0.200, "y_min": 0, "y_max": 8000},
        ]
        self.plot_ranges_refit = [
            {"x_min": 0, "x_max": 0.200, "y_min": 0, "y_max": 15000},
            {"x_min": 0, "x_max": 0.200, "y_min": 0, "y_max": 5000},
            {"x_min": 0, "x_max": 0.200, "y_min": 0, "y_max": 4000},
        ]

    def set_axes_style(self):
        """
        设置统一的坐标轴样式
        """
        plt.gca().spines["top"].set_linewidth(2)
        plt.gca().spines["bottom"].set_linewidth(2)
        plt.gca().spines["left"].set_linewidth(2)
        plt.gca().spines["right"].set_linewidth(2)
        plt.minorticks_on()

    def save_image(self, filename):
        """
        保存生成的图像并记录路径
        :param filename: 图像保存的文件名
        """
        # 定义保存路径
        directory = "./拟合图结果"

        # 检查路径是否存在，如果不存在则创建
        if not os.path.exists(directory):
            os.makedirs(directory)

        # 图像保存的完整路径
        image_path = os.path.join(directory, f"{filename}.png")

        # 记录图像路径
        self.images_paths.append(image_path)

        # 保存图像
        plt.savefig(image_path)
        plt.close()

    def add_auxiliary_lines(self, q_list, delta_theta_over_delta_q_list):
        """
        在图表中添加辅助线
        :param q_list: q值列表
        :param delta_theta_over_delta_q_list: Δθ/Δq值列表
        """
        for i in range(len(delta_theta_over_delta_q_list) - 1):
            plt.axvline(x=q_list[i], color="black", linestyle="dashed")
            plt.hlines(
                y=delta_theta_over_delta_q_list[i],
                xmin=q_list[i],
                xmax=q_list[i + 1],
                color="black",
            )
            plt.axvline(x=q_list[i + 1], color="black", linestyle="dashed")

        i = len(delta_theta_over_delta_q_list) - 1
        plt.axvline(x=q_list[i], color="black", linestyle="dashed")
        plt.hlines(
            y=delta_theta_over_delta_q_list[i],
            xmin=q_list[i],
            xmax=q_list[i],
            color="black",
        )
        plt.axvline(x=q_list[i], color="black", linestyle="dashed")

    def create_initial_fit_figure(
        self,
        group_index,
        q_to_fit,
        delta_theta_over_delta_q_to_fit,
        fit_slope,
        fit_intercept,
        q_list,
        delta_theta_over_delta_q_list,
        plot_range,
    ):
        """
        创建初拟合图表
        """
        plt.figure(figsize=(8, 6))
        plt.scatter(q_to_fit, delta_theta_over_delta_q_to_fit, color="red", label="拟合数据")
        plt.plot(q_to_fit, fit_slope * q_to_fit + fit_intercept, color="blue", label="拟合线")

        center_x = np.mean(q_to_fit)
        center_y = np.mean(delta_theta_over_delta_q_to_fit)
        equation_text = f"y = {fit_slope:.2f} * x + {fit_intercept:.2f}"
        plt.text(
            center_x,
            center_y,
            equation_text,
            color="black",
            fontsize=15,
            verticalalignment="top",
            weight="bold",
        )

        self.add_auxiliary_lines(q_list, delta_theta_over_delta_q_list)
        plt.xlim(plot_range["x_min"], plot_range["x_max"])
        plt.ylim(plot_range["y_min"], plot_range["y_max"])

        plt.xlabel("q 值")
        plt.ylabel("Δθ/Δq")
        plt.legend(loc="upper left")
        plt.figtext(0.5, 0.01, f"第{group_index+1}组数据初拟合", ha="center", fontsize=15)

        # 设置轴样式
        self.set_axes_style()

        # 调用自定义的 save_image 函数
        self.save_image(f"{2 * group_index + 1}")
        # plt.show()

    def create_refit_figure(
        self,
        group_index,
        filtered_data,
        refit_slope,
        refit_intercept,
        q_list,
        delta_theta_over_delta_q_list,
        plot_range,
    ):
        """
        创建重新拟合图表
        """
        plt.figure(figsize=(8, 6))
        plt.scatter(filtered_data[:, 0], filtered_data[:, 1], color="red", label="拟合数据")
        plt.plot(
            filtered_data[:, 0],
            refit_slope * filtered_data[:, 0] + refit_intercept,
            color="blue",
            label="拟合线",
        )

        center_x = np.mean(filtered_data[:, 0])
        center_y = np.mean(filtered_data[:, 1])
        equation_text = f"y = {refit_slope:.2f} * x + {refit_intercept:.2f}"
        plt.text(
            center_x,
            center_y,
            equation_text,
            color="black",
            fontsize=15,
            verticalalignment="top",
            weight="bold",
        )

        self.add_auxiliary_lines(q_list, delta_theta_over_delta_q_list)
        plt.xlim(plot_range["x_min"], plot_range["x_max"])
        plt.ylim(plot_range["y_min"], plot_range["y_max"])

        plt.xlabel("q 值")
        plt.ylabel("Δθ/Δq")
        plt.legend(loc="upper left")
        plt.figtext(
            0.5,
            0.01,
            f"第{group_index+1}组数据排除异常值后重新拟合",
            ha="center",
            fontsize=15,
        )

        self.set_axes_style()
        self.save_image(f"{2 * group_index + 2}")
        # plt.show()

    def generate_comparison_figures(self):
        """
        生成对比图
        """
        # 初始拟合对比图
        plt.figure(figsize=(8, 6))
        for group_index in range(3):
            (
                q_to_fit,
                delta_theta_over_delta_q_to_fit,
                delta_theta_over_delta_q_list,
                q_list,
            ) = self.calculator.process_single_group_data(group_index)
            model, _ = self.calculator.perform_linear_fit(q_to_fit, delta_theta_over_delta_q_to_fit)
            fit_slope = model.coef_[0]
            fit_intercept = model.intercept_

            plt.scatter(
                q_to_fit,
                delta_theta_over_delta_q_to_fit,
                label=f"第{group_index+1}组数据",
            )
            plt.plot(
                q_to_fit,
                fit_slope * q_to_fit + fit_intercept,
                label=f"拟合线{group_index+1}",
            )
            self.add_auxiliary_lines(q_list, delta_theta_over_delta_q_list)

        plt.xlim(0, 0.200)
        plt.xlabel("q 值")
        plt.ylabel("Δθ/Δq")
        plt.legend(loc="upper left")
        plt.figtext(0.5, 0.01, "三组数据保留所有数据点初拟合对比", ha="center", fontsize=15)

        self.set_axes_style()
        self.save_image("7")
        # plt.show()

        # 重新拟合对比图
        plt.figure(figsize=(8, 6))
        for i in range(3):
            plt.scatter(
                self.q_to_refit_lists[i],
                self.delta_theta_over_delta_q_to_refit_lists[i],
                label=f"第{i+1}组数据",
            )
            plt.plot(
                self.q_to_refit_lists[i],
                self.refit_slopes[i] * self.q_to_refit_lists[i] + self.refit_intercepts[i],
                label=f"拟合线{i+1}",
            )
            self.add_auxiliary_lines(
                self.q_to_refit_lists[i],
                self.delta_theta_over_delta_q_to_refit_lists[i],
            )

        plt.xlim(0, 0.200)
        plt.xlabel("q 值")
        plt.ylabel("Δθ/Δq")
        plt.legend(loc="upper left")
        plt.figtext(0.5, 0.01, "三组数据排除异常值后再拟合对比", ha="center", fontsize=15)

        self.set_axes_style()
        self.save_image("8")
        # plt.show()

    def integrate_figures(self):
        """
        合并所有绘图生成的图片并保存成一张图片
        """
        images = []
        for i in range(1, 9):
            img = mpimg.imread(f"./拟合图结果/{i}.png")
            images.append(img)

        fig, axes = plt.subplots(4, 2, figsize=(10, 12))
        for ax, img in zip(axes.flatten(), images):
            ax.imshow(img)
            ax.axis("off")

        plt.subplots_adjust(wspace=0.01, hspace=0.01)
        plt.savefig(r"./拟合图结果/拟合图整合图.png", bbox_inches="tight")
        # plt.show()

    def generate_all_figures(self):
        """
        生成所有必要的图形。
        """
        # 1. 画三张初拟合图
        for i in range(3):
            # 正确拆解数据
            (
                q_to_fit,
                delta_theta_over_delta_q_to_fit,
                delta_theta_over_delta_q_list,
                q_list,
            ) = self.calculator.process_single_group_data(i)

            # 执行线性拟合
            model, _ = self.calculator.perform_linear_fit(q_to_fit, delta_theta_over_delta_q_to_fit)
            fit_slope = model.coef_[0]
            fit_intercept = model.intercept_

            # 创建初拟合图
            self.create_initial_fit_figure(
                i,
                q_to_fit,
                delta_theta_over_delta_q_to_fit,
                fit_slope,
                fit_intercept,
                q_list,
                delta_theta_over_delta_q_list,
                self.plot_ranges_initial[i],
            )

        # 2. 画三张再拟合图
        for i in range(3):
            # 处理数据并获得回归线后的数据
            (
                q_to_fit,
                delta_theta_over_delta_q_to_fit,
                delta_theta_over_delta_q_list,
                q_list,
            ) = self.calculator.process_single_group_data(i)

            # 执行线性拟合
            model, fit_data = self.calculator.perform_linear_fit(q_to_fit, delta_theta_over_delta_q_to_fit)

            # 获取异常值
            outliers = self.calculator.detect_outliers(fit_data)

            # 重新拟合数据并移除异常值
            refit_model, filtered_data = self.calculator.refit_data_after_outlier_removal(fit_data, outliers)

            refit_slope = refit_model.coef_[0]
            refit_intercept = refit_model.intercept_

            # 创建重新拟合图
            self.create_refit_figure(
                i,
                filtered_data,
                refit_slope,
                refit_intercept,
                q_list,
                delta_theta_over_delta_q_list,
                self.plot_ranges_refit[i],
            )

        # 3. 生成对比图
        self.generate_comparison_figures()

        # 4. 生成整合图
        self.integrate_figures()


if __name__ == "__main__":
    plotter = Filteration_Plotter(r"./过滤原始数据记录表(非).csv")

    plotter.generate_all_figures()


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\plotters\fluid_flow_plotter.py 的内容:
================================================================================
# fluid_flow_plotter.py

# 内置库
import sys
import os

# 动态获取路径
current_script_path = os.path.abspath(__file__)
project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(current_script_path))))
sys.path.insert(0, project_root)


import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

from gui.screens.calculators.fluid_flow_calculator import Fluid_Flow_Calculator
from gui.screens.calculators.fluid_flow_calculator import Centrifugal_Pump_Characteristics_Calculator
from gui.screens.calculators.fluid_flow_calculator import Auxiliary


class Fluid_Flow_Plotter:
    def __init__(self, calculator):
        self.calculator = calculator
        self.ans1 = calculator.ans1
        self.df = calculator.df
        self.p = calculator.p
        self.log_Re = calculator.log_Re
        self.log_λ = calculator.log_λ
        self.valid_idx = calculator.valid_idx
        self.Re = self.ans1[:, 1]
        self.λ = self.ans1[:, 2]

    def plot(self):
        """绘制流体阻力分析结果"""
        # 设置字体
        plt.rcParams["font.sans-serif"] = ["SimHei"]
        plt.rcParams["axes.unicode_minus"] = False

        # 有效数据
        Re_valid = self.Re[self.valid_idx]
        λ_valid = self.λ[self.valid_idx]
        log_Re = np.log10(Re_valid)
        log_λ = np.log10(λ_valid)

        # 生成插值点
        log_Re_interp = np.linspace(log_Re.min(), log_Re.max(), 100)
        log_lambda_interp = self.p(log_Re_interp)

        # 绘制无插值图
        plt.figure(figsize=(8, 6), dpi=125)
        plt.scatter(log_Re, log_λ, color="b", label="数据点")
        plt.plot(log_Re, self.p(log_Re), color="red", label="拟合曲线")
        plt.xlabel("lg(Re)")
        plt.ylabel("lg(λ)")
        plt.title("雷诺数与阻力系数双对数拟合(无插值)")
        plt.grid(True)
        plt.legend()
        plt.savefig("./拟合图结果/雷诺数与阻力系数双对数拟合(无插值).png", dpi=300)
        plt.close()

        # plt.show()

        # 绘制有插值图
        plt.figure(figsize=(8, 6), dpi=125)
        plt.scatter(log_Re, log_λ, color="b", label="数据点")
        plt.plot(log_Re_interp, log_lambda_interp, color="r", label="插值曲线")
        plt.xlabel("lg(Re)")
        plt.ylabel("lg(λ)")
        plt.title("雷诺数与阻力系数双对数拟合(有插值)")
        plt.grid(True)
        plt.legend()
        plt.savefig("./拟合图结果/雷诺数与阻力系数双对数拟合(有插值).png", dpi=300)
        plt.close()

        # plt.show()


class Centrifugal_Pump_Characteristics_Plotter:
    def __init__(self, calculator):
        self.calculator = calculator
        self.ans2 = calculator.ans2
        self.df = calculator.df
        self.params_H = calculator.params_H
        self.params_N = calculator.params_N
        self.params_η = calculator.params_η

    @staticmethod
    def quadratic(x, a, b, c):
        return a * x**2 + b * x + c

    def plot(self):
        """绘制离心泵特性曲线"""
        # 设置字体
        plt.rcParams["font.sans-serif"] = ["SimHei"]
        plt.rcParams["axes.unicode_minus"] = False

        # 获取数据
        Q = self.df.iloc[:, 1].values  # 流量(m³/h)
        H = self.ans2[:, 0]  # 扬程(m)
        N_elc_e = self.ans2[:, 1]  # 有效功率(W)
        η = self.ans2[:, 2]  # 效率

        # 单位转换
        N_elc_e_kW = N_elc_e / 1000  # W → kW
        η_percent = η * 100  # 小数 → 百分比

        # 生成拟合数据
        Q_fit = np.linspace(Q.min(), Q.max(), 100)
        H_fit = self.quadratic(Q_fit, *self.params_H)
        N_fit = self.quadratic(Q_fit, *self.params_N) / 1000  # kW
        η_fit = self.quadratic(Q_fit, *self.params_η) * 100  # %

        # 创建图形
        fig, ax1 = plt.subplots(figsize=(7.85, 6), dpi=125)
        ax1.scatter(Q, H, color="blue", label="扬程数据")
        ax1.plot(Q_fit, H_fit, "b-", label="扬程拟合")
        ax1.set_xlabel("$Q/(m^3/h)$")
        ax1.set_ylabel("$H/m$", color="blue")
        ax1.tick_params(axis="y", labelcolor="blue")

        ax2 = ax1.twinx()
        ax2.scatter(Q, N_elc_e_kW, color="red", label="功率数据")
        ax2.plot(Q_fit, N_fit, "r--", label="功率拟合")
        ax2.set_ylabel("$N/kW$", color="red")
        ax2.tick_params(axis="y", labelcolor="red")

        ax3 = ax1.twinx()
        ax3.spines["right"].set_position(("outward", 60))
        ax3.scatter(Q, η_percent, color="green", label="效率数据")
        ax3.plot(Q_fit, η_fit, "g-.", label="效率拟合")
        ax3.set_ylabel("$\eta/\%$", color="green")
        ax3.tick_params(axis="y", labelcolor="green")

        fig.legend(loc="upper center", bbox_to_anchor=(0.5, 1.08), ncol=3)
        plt.title("离心泵特性曲线及二次拟合")
        plt.tight_layout(rect=[0.05, 0.03, 0.95, 0.93])
        plt.savefig("./拟合图结果/离心泵特性曲线及二次拟合.png", dpi=300)
        # plt.show()


class PlotManager:
    def __init__(self, auxiliary):
        self.auxiliary = auxiliary
        self.results = auxiliary.get_results()

    def plot_all(self):
        """绘制所有结果"""
        if "fluid" in self.results:
            fluid_calculator = Fluid_Flow_Calculator(self.auxiliary.file_paths[0])
            fluid_calculator.process()
            fluid_plotter = Fluid_Flow_Plotter(fluid_calculator)
            fluid_plotter.plot()

        if "pump" in self.results:
            pump_calculator = Centrifugal_Pump_Characteristics_Calculator(self.auxiliary.file_paths[1])
            pump_calculator.process()
            pump_plotter = Centrifugal_Pump_Characteristics_Plotter(pump_calculator)
            pump_plotter.plot()


if __name__ == "__main__":
    os.makedirs("./拟合图结果", exist_ok=True)

    # 文件路径列表
    file_paths = [
        "./csv_data/流体/流体原始数据记录表(非)/流体阻力原始数据.csv",
        "./csv_data/流体/流体原始数据记录表(非)/离心泵原始数据.csv",
    ]

    # 创建Auxiliary实例并处理文件
    auxiliary = Auxiliary(file_paths)
    auxiliary.process_files()

    # 创建PlotManager实例并绘制所有结果
    plot_manager = PlotManager(auxiliary)
    plot_manager.plot_all()


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\plotters\heat_transfer_plotter.py 的内容:
================================================================================
# heat_transfer_plotter.py

# 内置库
import sys
import os

# 动态获取路径
current_script_path = os.path.abspath(__file__)
project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(current_script_path))))
sys.path.insert(0, project_root)

import matplotlib.pyplot as plt

# 设置中文字体
plt.rcParams["font.family"] = "SimHei"
plt.rcParams["axes.unicode_minus"] = False
plt.rcParams["figure.dpi"] = 50
plt.rcParams["savefig.dpi"] = 300

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

from gui.screens.calculators.heat_transfer_calculator import Heat_Transfer_Calculator


class Heat_Transfer_Plotter:
    def __init__(self, calculator_results):
        """
        初始化画图类

        参数:
        calculator_results: 从Heat_Transfer_Calculator获取的结果数据
        """
        self.results = calculator_results
        self.setup_plot_style()  # 初始化时设置全局样式

    def fit_func(self, x, a, b):
        """
        拟合函数，用于曲线拟合。

        参数:
        x (numpy.ndarray): 自变量
        a (float): 拟合参数
        b (float): 拟合参数

        返回:
        numpy.ndarray: 拟合结果
        """
        return a + b * x

    def setup_plot_style(self):
        """统一配置绘图样式"""
        plt.rcParams.update(
            {
                "font.family": "Microsoft YaHei",
                "font.size": 12,
                "axes.unicode_minus": False,
                "figure.dpi": 50,
                "savefig.dpi": 300,
                "axes.linewidth": 2,
                "grid.linestyle": "-",
                "grid.linewidth": 1,
                "mathtext.default": "regular",
                "font.sans-serif": ["Microsoft YaHei", "SimHei", "DejaVu Sans"],  # 字体回退列表
                "text.usetex": False,
                "mathtext.fontset": "dejavusans",  # 使用与中文字体兼容的数学字体
            }
        )

    def create_directory(self, filepath):
        """确保文件保存路径存在"""
        directory = os.path.dirname(filepath)
        if not os.path.exists(directory):
            os.makedirs(directory, exist_ok=True)

    def configure_plot(self, title):
        """配置通用绘图参数"""
        plt.xscale("log")
        plt.yscale("log")
        plt.xlabel(r"$\mathrm{Re}$", fontsize=14, fontweight="bold")
        plt.ylabel(r"$\mathrm{Nu/Pr^{0.4}}$", fontsize=14, fontweight="bold")
        plt.title(title, fontsize=10, fontweight="bold")
        plt.grid(True, which="both")
        plt.minorticks_on()
        ax = plt.gca()
        for spine in ax.spines.values():
            spine.set_linewidth(2)

    def plot_fit(self, data_for_fit, filename, title):
        """优化后的拟合绘图方法"""
        if len(data_for_fit) == 0:
            print(f"警告：跳过 {title} 的绘图，数据为空")
            return

        try:
            # 曲线拟合
            ans_params, _ = curve_fit(
                self.fit_func,
                np.log10(data_for_fit[:, 0]),
                np.log10(data_for_fit[:, 1]),
            )
        except Exception as e:
            print(f"曲线拟合失败：{str(e)}")
            return

        # 配置图形
        plt.figure(figsize=(8, 6), dpi=125)
        self.configure_plot(title)

        # 绘制数据点及拟合曲线
        plt.scatter(data_for_fit[:, 0], data_for_fit[:, 1], color="r", label="实验数据")
        plt.plot(
            data_for_fit[:, 0],
            10 ** self.fit_func(np.log10(data_for_fit[:, 0]), *ans_params),
            color="k",
            label="拟合曲线",
        )

        # 添加拟合方程文本
        equation_text = f"拟合方程: y = {10**ans_params[0]:.10f} * x^{ans_params[1]:.2f}"
        plt.text(
            0.05,
            0.95,
            equation_text,
            transform=plt.gca().transAxes,
            fontsize=12,
            verticalalignment="top",
            bbox=dict(boxstyle="round", facecolor="white", alpha=0.8),
        )

        # 保存输出
        self.create_directory(filename)
        plt.legend()
        plt.savefig(filename, bbox_inches="tight")
        plt.close()

    def generate_plots(self):
        """生成所有分析图表"""
        # 处理第一组数据（无强化套管）
        if len(self.results) > 0 and self.results[0]["params"] is not None:
            self.plot_fit(
                self.results[0]["data_for_fit"],
                "./传热拟合图结果/无强化套管拟合.png",
                "无强化套管传热性能分析",
            )

        # 处理第二组数据（有强化套管）
        if len(self.results) > 1 and self.results[1]["params"] is not None:
            self.plot_fit(
                self.results[1]["data_for_fit"],
                "./传热拟合图结果/有强化套管拟合.png",
                "有强化套管传热性能分析",
            )

        # 生成对比图
        self.generate_comparison_plot()

    def generate_comparison_plot(self):
        """生成对比分析图"""
        has_valid_data = False
        plt.figure(figsize=(10, 8), dpi=125)
        self.configure_plot("传热性能对比分析")

        # 绘制第一组数据（无强化套管）
        if len(self.results) > 0 and self.results[0]["params"] is not None:
            data = self.results[0]["data_for_fit"]
            plt.scatter(
                data[:, 0],
                data[:, 1],
                color="r",
                marker="o",
                s=80,
                label="无强化套管实验数据",
            )
            plt.plot(
                data[:, 0],
                10 ** self.fit_func(np.log10(data[:, 0]), *self.results[0]["params"]),
                color="r",
                linestyle="--",
                linewidth=2,
                label="无强化套管拟合曲线",
            )
            has_valid_data = True

        # 绘制第二组数据（有强化套管）
        if len(self.results) > 1 and self.results[1]["params"] is not None:
            data = self.results[1]["data_for_fit"]
            plt.scatter(
                data[:, 0],
                data[:, 1],
                color="b",
                marker="s",
                s=80,
                label="有强化套管实验数据",
            )
            plt.plot(
                data[:, 0],
                10 ** self.fit_func(np.log10(data[:, 0]), *self.results[1]["params"]),
                color="b",
                linestyle="-.",
                linewidth=2,
                label="有强化套管拟合曲线",
            )
            has_valid_data = True

        if has_valid_data:
            self.create_directory("./传热拟合图结果/传热性能对比.png")
            plt.legend(fontsize=12, loc="upper left")
            plt.savefig("./传热拟合图结果/传热性能对比.png", bbox_inches="tight")
            plt.close()
        else:
            print("警告：无有效数据生成对比图")


# 使用示例
if __name__ == "__main__":
    # 定义CSV文件路径列表
    csv_file_paths = [
        "原始数据_无强化套管.csv",
        "原始数据_有强化套管.csv",
        "数据预处理_无强化套管.csv",
        "数据预处理_有强化套管.csv",
    ]

    # 实例化传热计算器（需要确保Heat_Transfer_Calculator已修改为接受CSV文件）
    heat_transfer_calculator = Heat_Transfer_Calculator(csv_file_paths)

    # 数据处理
    heat_transfer_calculator.process_data()

    # 创建作图器并传递计算结果
    plotter = Heat_Transfer_Plotter(heat_transfer_calculator.results)

    # 生成并保存图表
    plotter.generate_plots()


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\plotters\oxygen_desorption_plotter.py 的内容:
================================================================================
# oxygen_desorption_plotter.py

# 内置库
import sys
import os


# 动态获取路径
current_script_path = os.path.abspath(__file__)
project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(current_script_path))))
sys.path.insert(0, project_root)

from pathlib import Path
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
from scipy.stats import pearsonr
import warnings

warnings.filterwarnings("ignore")


from gui.screens.calculators.oxygen_desorption_calculator import Oxygen_Desorption_Calculator
from gui.screens.calculators.oxygen_desorption_calculator import Packed_Tower_Calculator


class Packed_Tower_Plotter:
    def __init__(self, calculator):
        self.calculator = calculator
        self._init_plot_style()

    def _init_plot_style(self):
        plt.rcParams["font.family"] = "SimHei"
        plt.rcParams["axes.unicode_minus"] = False

    def plot_comparison(self, save_path=None):
        plt.figure(figsize=(10, 6))

        # 确保有分析结果
        if not self.calculator.results:
            raise ValueError("没有可用的分析结果，请先运行analyze_all_files()")

        # 绘制干填料数据
        dry_data = next((r for r in self.calculator.results if "干填料" in r["csv_file"]), None)
        if dry_data:
            self._plot_single(dry_data, "干填料", "red")

        # 绘制湿填料数据
        wet_data = next((r for r in self.calculator.results if "湿填料" in r["csv_file"]), None)
        if wet_data:
            self._plot_single(wet_data, "湿填料", "blue")

        plt.xlabel("空塔气速 u (m/s)")
        plt.ylabel("单位高度压降 Δp/Z (kPa/m)")
        plt.title("填料塔流体力学性能对比")
        plt.legend()
        plt.grid(True)
        plt.xlim(0, 1.3)
        plt.ylim(0, 40)
        ExperimentUtils.set_spine_width(plt.gca())

        # 处理保存路径
        output_path = save_path if save_path else "./拟合图结果/填料塔性能对比.png"
        Path(output_path).parent.mkdir(parents=True, exist_ok=True)
        plt.savefig(output_path, dpi=300, bbox_inches="tight")
        # plt.show()

    def _plot_single(self, data, label, color):
        u = data["u"]
        delta_p = data["delta_p"]
        popt = data["popt"]

        plt.scatter(u, delta_p, color=color, label=label)
        x_fit = np.linspace(min(u), max(u), 100)

        if data["fit_type"] == "linear":
            y_fit = self.calculator.linear_fit(x_fit, *popt)
            eq = f"$Δp/Z = {popt[0]:.1f}u + {popt[1]:.1f}$"
        else:
            y_fit = self.calculator.taylor_fit(x_fit, *popt)
            eq = self._format_taylor_eq(popt)

        plt.plot(x_fit, y_fit, "k--", label=eq)

    @staticmethod
    def _format_taylor_eq(coefficients):
        terms = []
        for i, coeff in enumerate(coefficients):
            if abs(coeff) > 1e-6:  # 忽略接近零的系数
                term = f"{coeff:.1f}u^{i}" if i > 0 else f"{coeff:.1f}"
                terms.append(term)
        return "$Δp/Z = " + "+".join(terms) + "$" if terms else ""


class Oxygen_Desorption_Plotter:
    def __init__(self, calculator):
        self.calculator = calculator
        self._init_plot_style()

    def _init_plot_style(self):
        plt.rcParams["font.family"] = "SimHei"
        plt.rcParams["axes.unicode_minus"] = False

    def plot_correlation(self, save_path=None):
        plt.figure(figsize=(8, 8))

        # 确保有分析结果
        if not self.calculator.results:
            raise ValueError("没有可用的分析结果，请先运行analyze_all_files()")

        for result in self.calculator.results:
            csv_file = result["csv_file"]
            label = Path(csv_file).stem.replace("_", " ")
            plt.scatter(result["L"], result["Kxa"], label=label)

        plt.xlabel("液相流量 L (mol/s)")
        plt.ylabel("传质系数 Kxa")
        plt.title("氧解吸传质系数关联")
        plt.legend()
        plt.grid(True)
        ExperimentUtils.set_spine_width(plt.gca())

        # 处理保存路径
        output_path = save_path if save_path else "./拟合图结果/氧解吸传质关联.png"
        Path(output_path).parent.mkdir(parents=True, exist_ok=True)
        plt.savefig(output_path, dpi=300, bbox_inches="tight")
        # plt.show()


class ExperimentUtils:
    @staticmethod
    def set_spine_width(ax, width=2):
        """设置图表边框粗细"""
        for spine in ax.spines.values():
            spine.set_linewidth(width)


# ====================== 主程序 ======================
if __name__ == "__main__":
    from gui.screens.calculators.oxygen_desorption_calculator import (
        ExperimentDataLoader,
        Packed_Tower_Calculator,
        Oxygen_Desorption_Calculator,
    )

    try:
        # 初始化数据加载器，直接传入四个文件的全路径
        data_loader = ExperimentDataLoader(
            dry_packed="./csv_data/解吸原始记录表(非)/干填料.csv",
            wet_packed="./csv_data/解吸原始记录表(非)/湿填料.csv",
            water_constant="./csv_data/解吸原始记录表(非)/水流量一定_空气流量改变.csv",
            air_constant="./csv_data/解吸原始记录表(非)/空气流量一定_水流量改变.csv",
        )

        # 填料塔分析
        tower_calculator = Packed_Tower_Calculator(data_loader)
        tower_calculator.analyze_all_files()
        tower_plotter = Packed_Tower_Plotter(tower_calculator)
        tower_plotter.plot_comparison()

        # 氧解吸分析
        oxygen_calculator = Oxygen_Desorption_Calculator(data_loader)
        oxygen_calculator.analyze_all_files()
        oxygen_plotter = Oxygen_Desorption_Plotter(oxygen_calculator)
        oxygen_plotter.plot_correlation()

    except FileNotFoundError as e:
        print(f"错误: {str(e)}")
        print("请确保所有必需文件都存在")
    except Exception as e:
        print(f"发生未知错误: {str(e)}")


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\plotters\__init__.py 的内容:
================================================================================


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\processors\distillation_experiment_processor.py 的内容:
================================================================================
# distillation_experiment_processor.py

import os
import sys
import zipfile
import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path

# 动态获取路径
current_script_path = os.path.abspath(__file__)
project_root = Path(current_script_path).parents[3]
sys.path.insert(0, str(project_root))

from gui.screens.calculators.distillation_calculator import Distillation_Calculator
from gui.screens.plotters.distillation_plotter import Distillation_Plotter


class Distillation_Experiment_Processor:
    """
    精馏实验流程处理器

    功能扩展：
    - 自动化执行完整实验流程
    - 结果文件管理
    - 数据打包输出

    主要方法：
    process_experiment() - 执行完整处理流程
    """

    def __init__(self, file_path, R, αm, F, tS, tF, output_dir="实验结果"):
        """
        初始化实验处理器

        参数：
        output_dir (str): 结果输出目录
        """
        # 回流比
        self.R = R

        # 初始化计算引擎
        self.calculator = Distillation_Calculator(file_path=file_path, R=R, αm=αm, F=F, tS=tS, tF=tF)

        # 初始化可视化引擎
        self.plotter = Distillation_Plotter(self.calculator)

        # 配置输出路径
        self.file_path = file_path
        self.output_dir = Path(output_dir)
        self.base_name = Path(file_path).stem
        self._prepare_directory()

    def _prepare_directory(self):
        """创建结构化输出目录"""
        (self.output_dir / "原始数据").mkdir(parents=True, exist_ok=True)
        (self.output_dir / "计算结果").mkdir(parents=True, exist_ok=True)
        (self.output_dir / "拟合图结果").mkdir(parents=True, exist_ok=True)

    def process_experiment(self, show_plot=False):
        """
        执行完整实验处理流程

        参数：
        show_plot (bool): 是否显示可视化图表
        """
        try:
            # 保存计算结果
            self._save_text_results()

            # 生成可视化
            self._generate_plots(show=show_plot)

            # 打包结果
            self._create_archive()

            print(f"实验处理完成，结果保存在：{self.output_dir.resolve()}")
            return True
        except Exception as e:
            print(f"处理失败：{str(e)}")
            return False

    def _save_text_results(self):
        """保存文本计算结果"""
        result_path = self.output_dir / "计算结果" / f"{self.base_name}_results.txt"
        self.calculator.save_results(str(result_path))

    def _generate_plots(self, show=True):
        """生成可视化图表"""
        plot_path = self.output_dir / "拟合图结果" / f"{self.base_name}.png"
        self.plotter.plot_mccabe_thiele(save_path=str(plot_path), show=show)

    def _create_archive(self):
        """创建ZIP打包文件"""
        zip_path = self.output_dir / f"{self.base_name}_results.zip"

        with zipfile.ZipFile(zip_path, "w") as zipf:
            # 原始数据
            zipf.write(self.file_path, arcname=f"原始数据/{Path(self.file_path).name}")

            # 计算结果
            text_file = self.output_dir / "计算结果" / f"{self.base_name}_results.txt"
            zipf.write(text_file, arcname=text_file.name)

            # 可视化结果
            plot_file = self.output_dir / "拟合图结果" / f"{self.base_name}.png"
            zipf.write(plot_file, arcname=plot_file.name)

    @property
    def result_paths(self):
        """获取各结果文件路径"""
        return {
            "original_data": self.file_path,
            "text_results": self.output_dir / "计算结果" / f"{self.base_name}_results.txt",
            "visualization": self.output_dir / "拟合图结果" / f"{self.base_name}.png",
            "archive": self.output_dir / f"{self.base_name}_results.zip",
        }


if __name__ == "__main__":
    # 使用示例
    DATA_FILE = "./csv_data/精馏/精馏原始记录表(非)/Sheet1.csv"

    # 处理常规回流比 (R=4)
    processor_normal = Distillation_Experiment_Processor(
        file_path=DATA_FILE, R=4, αm=2.0, F=80, tS=30, tF=26, output_dir="实验结果/R4"
    )
    processor_normal.process_experiment(show_plot=True)

    # 处理全回流 (R=+∞)
    processor_infinite = Distillation_Experiment_Processor(
        file_path=DATA_FILE, R=10000, αm=2.0, F=80, tS=30, tF=26, output_dir="实验结果/全回流"
    )
    processor_infinite.process_experiment()


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\processors\drying_experiment_processor.py 的内容:
================================================================================
# drying_experiment_processor.py

# 内置库
import sys
import os
import numpy as np
import pandas as pd
import zipfile

# 动态获取路径
current_script_path = os.path.abspath(__file__)
project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(current_script_path))))
sys.path.insert(0, project_root)

from gui.screens.calculators.drying_calculator import Drying_Calculator
from gui.screens.plotters.drying_plotter import Drying_Plotter


class Drying_Experiment_Processor(Drying_Calculator):
    def __init__(self, csv_file_paths):
        """
        初始化实验处理器，直接传入CSV文件路径列表
        """
        super().__init__(csv_file_paths)
        self._plotter = None  # 绘图器实例，初始化时为None

    def process_experiment(self, output_dir="./拟合结果"):
        """
        处理整个干燥实验过程
        包括计算、绘图和结果输出
        """
        # 运行完整计算
        self.run_full_calculation()

        # 创建绘图器实例（如果尚未创建）
        if self._plotter is None:
            self._plotter = Drying_Plotter(self)

        # 运行完整绘图
        return self._plotter.run_full_plotting(output_dir)

    def get_results(self):
        """
        获取完整的计算结果
        """
        return self.results

    def get_plots(self, plot_type="combined"):
        """
        获取绘图结果
        可选参数：plot_type ('combined', 'curve', 'rate')
        """
        # 确保绘图器已经创建
        if self._plotter is None:
            self._plotter = Drying_Plotter(self)

        if plot_type == "combined":
            return self._plotter.integrate_images()
        elif plot_type == "curve":
            return self._plotter.plot_drying_curve()
        elif plot_type == "rate":
            return self._plotter.plot_drying_rate_curve()
        else:
            raise ValueError("无效的绘图类型，请选择 'combined', 'curve' 或 'rate'")

    def __str__(self):
        return f"Drying_Experiment_Processor处理了{len(self.csv_file_paths)}个CSV文件"


# 使用示例
if __name__ == "__main__":
    csv_files = [
        "./csv_data/干燥原始数据记录表(非)/原始数据1.csv",
        "./csv_data/干燥原始数据记录表(非)/原始数据2.csv",
    ]

    # 初始化实验处理器
    processor = Drying_Experiment_Processor(csv_files)

    # 处理实验并输出结果
    outputs = processor.process_experiment()

    print("实验处理完成，生成结果如下：")
    print(f"- 组合图表: {outputs['combined_plot']}")
    print(f"- 压缩包: {outputs['zip_archive']}")
    print(f"- 序列化数据: {outputs['serialized_data']}")

    # 获取计算结果
    results = processor.get_results()

    # 打印部分计算结果
    print("\n部分计算结果：")
    print(f"恒定干燥速率 U_c: {processor.U_c}")
    print(f"传热系数 α: {processor.α}")


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\processors\extraction_expriment_processor.py 的内容:
================================================================================
# extraction_experiment_processor.py

# 内置库
import sys
import os

# 动态获取路径
current_script_path = os.path.abspath(__file__)
project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(current_script_path))))
sys.path.insert(0, project_root)

import logging

# 配置日志设置
logging.basicConfig(level=logging.DEBUG, format="%(asctime)s - %(levelname)s - %(message)s")

import argparse
from gui.screens.calculators.extraction_calculator import Extraction_Calculator
from gui.screens.plotters.extraction_plotter import Extraction_Plotter


class ExtractionExperimentProcessor:
    def __init__(self, main_file=None, distribution_file=None):
        """
        初始化实验处理器
        :param main_file: 主数据文件路径
        :param distribution_file: 分配曲线数据文件路径
        """
        self.main_file = main_file
        self.distribution_file = distribution_file
        self.calculator = None
        self.plotter = None

        # 结果输出配置
        self.output_dir = "./拟合图结果"
        self.zip_file = "萃取分析结果.zip"

    def validate_files(self):
        """验证输入文件有效性"""
        missing_files = []
        if not os.path.exists(self.main_file):
            missing_files.append(self.main_file)
        if not os.path.exists(self.distribution_file):
            missing_files.append(self.distribution_file)

        if missing_files:
            raise FileNotFoundError(f"以下必要文件缺失：{', '.join(missing_files)}")

    def setup_components(self):
        """初始化各处理组件"""
        self.calculator = Extraction_Calculator(self.main_file, self.distribution_file)
        self.plotter = Extraction_Plotter(self.calculator)
        self.plotter.output_dir = self.output_dir

    def process_data(self):
        """执行完整数据处理流程"""
        # 数据计算阶段
        self.calculator.run_calculations()

        # 可视化阶段
        self.plotter.create_output_dir()
        print("\n正在生成分析图表...")
        self.plotter.plot_main_curves()
        self.plotter.plot_integration_curves()

        # 结果打包
        print("正在打包结果文件...")
        self.plotter.package_results(self.zip_file)

    def print_summary(self):
        """输出处理结果摘要"""
        print(f"\n{'='*40}")
        print("处理完成！结果文件已保存至：")
        print(f"- 图表目录: {os.path.abspath(self.output_dir)}")
        print(f"- 压缩包文件: {os.path.abspath(self.zip_file)}")
        print(f"{'='*40}")

    def run(self):
        """主执行流程"""
        try:
            self.validate_files()
            self.setup_components()
            self.process_data()
            self.print_summary()
        except Exception as e:
            print(f"\n处理过程中发生错误：{str(e)}")
            print("建议检查：")
            print("1. 输入文件格式是否符合要求")
            print("2. 数据列是否完整")
            print("3. 系统字体配置是否正确")
            raise


def parse_arguments():
    """解析命令行参数"""
    parser = argparse.ArgumentParser(description="萃取实验数据处理系统")
    parser.add_argument(
        "--main",
        type=str,
        default="./1 原始数据记录.csv",
        help="主数据文件路径",
    )
    parser.add_argument(
        "--distribution",
        type=str,
        default="./3 分配曲线数据集.csv",
        help="分配曲线数据文件路径",
    )
    return parser.parse_args()


if __name__ == "__main__":
    # 命令行参数解析
    args = parse_arguments()

    # 创建处理器实例并运行
    processor = ExtractionExperimentProcessor(main_file=args.main, distribution_file=args.distribution)
    processor.run()


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\processors\filteration_experiment_processor.py 的内容:
================================================================================
# filteration_experiment_processor.py

# 内置库
import sys
import os

# 动态获取项目根路径
current_script_path = os.path.abspath(__file__)
project_root = os.path.dirname(os.path.dirname(os.path.dirname(current_script_path)))
sys.path.insert(0, project_root)

import zipfile
import matplotlib.pyplot as plt
from gui.screens.calculators.filteration_calculator import Filteration_Calculator
from gui.screens.plotters.filteration_plotter import Filteration_Plotter

# 设置中文字体
plt.rcParams["font.family"] = "SimHei"
plt.rcParams["axes.unicode_minus"] = False
plt.rcParams["figure.dpi"] = 50
plt.rcParams["savefig.dpi"] = 300


class Filteration_Experiment_Processor:
    """
    负责处理过滤实验数据的类。
    该类处理数据加载、拟合、异常值检测以及生成结果图形。
    """

    def __init__(self, csv_file_path):
        """
        初始化类并加载CSV文件以进行进一步处理。
        :param csv_file_path: 包含数据的CSV文件路径
        """
        self.csv_file_path = csv_file_path

        # 初始化计算类处理数据
        self.calculator = Filteration_Calculator(csv_file_path)

        # 初始化绘图类生成图形
        self.plotter = Filteration_Plotter(csv_file_path)

        # 初始化一个列表来存储处理后的数据
        self.processed_data = []

        # 存储来自Filteration_Calculator和Filteration_Plotter的数据
        self.calculator_data = {
            "data": self.calculator.data,
            "q_to_refit_lists": self.calculator.q_to_refit_lists,
            "delta_theta_over_delta_q_to_refit_lists": self.calculator.delta_theta_over_delta_q_to_refit_lists,
            "refit_slopes": self.calculator.refit_slopes,
            "refit_intercepts": self.calculator.refit_intercepts,
            "selected_data": self.calculator.selected_data,
            "data_array": self.calculator.data_array,
            "deltaV": self.calculator.deltaV,
            "S": self.calculator.S,
            "deltaQ": self.calculator.deltaQ,
            "delta_theta_list": self.calculator.delta_theta_list,
            "delta_q_list": self.calculator.delta_q_list,
            "delta_theta_over_delta_q_list": self.calculator.delta_theta_over_delta_q_list,
            "q_list": self.calculator.q_list,
            "q_to_fit": self.calculator.q_to_fit,
            "delta_theta_over_delta_q_to_fit": self.calculator.delta_theta_over_delta_q_to_fit,
            "fit_model": self.calculator.fit_model,
            "fit_data": self.calculator.fit_data,
            "fit_slope": self.calculator.fit_slope,
            "fit_intercept": self.calculator.fit_intercept,
            "outliers": self.calculator.outliers,
            "refit_model": self.calculator.refit_model,
            "filtered_data": self.calculator.filtered_data,
        }

        self.plotter_data = {
            "q_to_refit_lists": self.plotter.q_to_refit_lists,
            "delta_theta_over_delta_q_to_refit_lists": self.plotter.delta_theta_over_delta_q_to_refit_lists,
            "refit_slopes": self.plotter.refit_slopes,
            "refit_intercepts": self.plotter.refit_intercepts,
        }

    def calculate(self):
        """
        使用计算类处理数据。
        处理各组数据并返回进一步分析所需的信息。
        """
        # 处理所有组的数据并存储结果
        (
            self.q_to_refit_lists,
            self.delta_theta_over_delta_q_to_refit_lists,
            self.refit_slopes,
            self.refit_intercepts,
        ) = self.calculator.process_all_groups()

    def store(self):
        """
        将处理后的数据存储到类的processed_data列表中。
        这些数据将用于生成结果和图形。
        """
        for i in range(3):
            # 存储每组处理后的数据（q值、斜率、截距）到字典中
            group_data = {
                "group": i + 1,
                "q_values": self.q_to_refit_lists[i],
                "slope": self.refit_slopes[i],
                "intercept": self.refit_intercepts[i],
            }
            # 将每组的数据添加到processed_data列表中
            self.processed_data.append(group_data)

    def plot(self):
        """
        使用绘图类基于处理后的数据生成所有所需的图形。
        """
        # 使用绘图类生成图形
        self.plotter.generate_all_figures()

    def compress_results(self):
        """
        将生成的图像文件压缩成一个zip文件，便于分发和存储。
        """
        dir_to_zip = r"./拟合图结果"  # 存放结果的目录
        dir_to_save = r"./拟合图结果.zip"  # 目标zip文件路径

        # 创建zip文件并将结果目录中的所有文件添加进去
        with zipfile.ZipFile(dir_to_save, "w", zipfile.ZIP_DEFLATED) as zipf:
            for root, dirs, files in os.walk(dir_to_zip):
                for file in files:
                    file_dir = os.path.join(root, file)
                    arc_name = os.path.relpath(file_dir, dir_to_zip)
                    zipf.write(file_dir, arc_name)

        # 打印压缩完成的确认信息
        print(f"压缩完成。文件已保存为: {dir_to_save}")


if __name__ == "__main__":
    # 定义CSV文件的路径进行处理
    csv_file_path = r"./过滤原始数据记录表(非).csv"

    # 初始化处理类
    processor = Filteration_Experiment_Processor(csv_file_path)

    # 第一步：处理数据（包括拟合、异常值检测等）
    processor.calculate()  # 处理数据（计算、拟合等）

    # 第二步：存储处理后的数据（可选步骤，用于生成结果或摘要）
    processor.store()  # 存储处理后的数据

    # 第三步：基于处理后的数据生成图形
    processor.plot()  # 生成图形（初拟合、再拟合等）

    # 第四步：压缩结果图像文件为zip文件
    processor.compress_results()  # 将生成的结果文件压缩成zip文件


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\processors\fluid_flow_experiment_processor.py 的内容:
================================================================================
# fluid_flow_experiment_processor.py

# 内置库
import sys
import os

# 动态获取项目根路径
current_script_path = os.path.abspath(__file__)
project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(current_script_path))))
sys.path.insert(0, project_root)

from gui.screens.calculators.fluid_flow_calculator import (
    Fluid_Flow_Calculator,
    Centrifugal_Pump_Characteristics_Calculator,
    Auxiliary,
)
from gui.screens.plotters.fluid_flow_plotter import Fluid_Flow_Plotter, Centrifugal_Pump_Characteristics_Plotter


class Fluid_Flow_Expriment_Processor:
    def __init__(self, file_paths):
        """初始化实验处理器，设置数据文件路径"""
        self.file_paths = file_paths
        self.output_dir = "./拟合图结果"

        # 确保输出目录存在
        os.makedirs(self.output_dir, exist_ok=True)

        # 初始化计算器和绘图器
        self.fluid_calculator = None
        self.pump_calculator = None
        self.fluid_plotter = None
        self.pump_plotter = None

        # 初始化辅助类
        self.auxiliary = Auxiliary(file_paths)

    def process_fluid_flow(self):
        """处理流体阻力实验数据"""
        fluid_file_path = self.auxiliary.identify_file_type(self.file_paths[0])
        if fluid_file_path == "fluid":
            self.fluid_calculator = Fluid_Flow_Calculator(self.file_paths[0])
            ans1, df1 = self.fluid_calculator.process()
            self.fluid_plotter = Fluid_Flow_Plotter(self.fluid_calculator)
            return ans1, df1
        else:
            raise ValueError("第一个文件不是流体阻力数据文件")

    def process_pump_characteristics(self):
        """处理离心泵特性实验数据"""
        pump_file_path = self.auxiliary.identify_file_type(self.file_paths[1])
        if pump_file_path == "pump":
            self.pump_calculator = Centrifugal_Pump_Characteristics_Calculator(self.file_paths[1])
            ans2, df2, params_H, params_N, params_η = self.pump_calculator.process()
            self.pump_plotter = Centrifugal_Pump_Characteristics_Plotter(self.pump_calculator)
            return ans2, df2, params_H, params_N, params_η
        else:
            raise ValueError("第二个文件不是离心泵数据文件")

    def generate_all_plots(self):
        """生成所有分析图表"""
        if not self.fluid_plotter:
            self.process_fluid_flow()
        if not self.pump_plotter:
            self.process_pump_characteristics()

        self.fluid_plotter.plot()
        self.pump_plotter.plot()

    def get_fluid_flow_results(self):
        """获取流体阻力实验结果"""
        if not self.fluid_calculator:
            self.process_fluid_flow()
        return {
            "velocity": self.fluid_calculator.ans1[:, 0],
            "reynolds": self.fluid_calculator.ans1[:, 1],
            "friction_factor": self.fluid_calculator.ans1[:, 2],
            "log_reynolds": self.fluid_calculator.log_Re,
            "log_friction": self.fluid_calculator.log_λ,
            "polynomial": self.fluid_calculator.p,
        }

    def get_pump_characteristics_results(self):
        """获取离心泵特性实验结果"""
        if not self.pump_calculator:
            self.process_pump_characteristics()
        return {
            "head": self.pump_calculator.ans2[:, 0],
            "power": self.pump_calculator.ans2[:, 1],
            "efficiency": self.pump_calculator.ans2[:, 2],
            "head_params": self.pump_calculator.params_H,
            "power_params": self.pump_calculator.params_N,
            "efficiency_params": self.pump_calculator.params_η,
        }


if __name__ == "__main__":
    # 文件路径列表
    file_paths = [
        "./csv_data/流体/流体原始数据记录表(非)/流体阻力原始数据.csv",
        "./csv_data/流体/流体原始数据记录表(非)/离心泵原始数据.csv",
    ]

    # 创建实验处理器实例
    processor = Fluid_Flow_Expriment_Processor(file_paths)

    # 处理流体阻力数据
    fluid_ans, fluid_df = processor.process_fluid_flow()

    # 处理离心泵数据
    pump_ans, pump_df, pump_params_H, pump_params_N, pump_params_η = processor.process_pump_characteristics()

    # 生成所有图表
    processor.generate_all_plots()

    # 获取结果
    fluid_results = processor.get_fluid_flow_results()
    pump_results = processor.get_pump_characteristics_results()

    # 打印结果
    print("流体阻力实验结果:", fluid_results)
    print("离心泵特性实验结果:", pump_results)


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\processors\heat_transfer_experiment_processor.py 的内容:
================================================================================
# heat_transfer_experiment_processor.py

# 内部库
import sys
import os

# 动态获取项目根路径
current_script_path = os.path.abspath(__file__)
project_root = os.path.dirname(os.path.dirname(os.path.dirname(current_script_path)))
sys.path.insert(0, project_root)

import zipfile
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

from gui.screens.calculators.heat_transfer_calculator import Heat_Transfer_Calculator
from gui.screens.plotters.heat_transfer_plotter import Heat_Transfer_Plotter

# 设置中文字体
plt.rcParams["font.family"] = "SimHei"
plt.rcParams["axes.unicode_minus"] = False
plt.rcParams["figure.dpi"] = 50
plt.rcParams["savefig.dpi"] = 300


class Heat_Transfer_Experiment_Processor:
    """
    负责处理传热实验数据的类。
    该类处理数据加载、计算、拟合、异常值检测以及生成结果图形。
    修改为处理CSV文件而非Excel文件。
    """

    def __init__(self, csv_file_paths):
        """
        初始化类并加载CSV文件以进行进一步处理。
        :param csv_file_paths: 包含传热实验数据的CSV文件路径列表
        """
        self.csv_file_paths = csv_file_paths  # 存储CSV文件路径列表

        # 初始化计算类处理数据
        self.calculator = Heat_Transfer_Calculator(csv_file_paths)

        # 初始化绘图类生成图形
        self.plotter = Heat_Transfer_Plotter(self.calculator.results)

        # 初始化一个列表来存储处理后的数据
        self.processed_data = []

        # 存储来自计算器处理后的数据
        self.calculator_data = {"results": self.calculator.results}

    def calculate(self):
        """
        使用计算类处理传热实验数据。
        处理各组数据并返回拟合结果和计算信息。
        """
        # 加载数据
        datasets = self.calculator.load_data()

        # 数据预处理（已在初始化中完成）

        # 数据处理
        self.calculator.process_data()

    def store(self):
        """
        将处理后的数据存储到类的processed_data列表中。
        这些数据将用于生成结果和图形。
        """
        for idx, result in enumerate(self.calculator.results):
            group_data = {
                "group": idx + 1,
                "type": "无强化套管" if idx == 0 else "有强化套管",
                "data_for_fit": result["data_for_fit"],
                "params": result["params"],
                "original_data": result["original_data"],
                "calculated_data": result["calculated_data"],
            }
            self.processed_data.append(group_data)

    def plot(self):
        """
        使用绘图类基于处理后的数据生成所有所需的图形。
        """
        # 生成并保存图表
        self.plotter.generate_plots()

    def compress_results(self):
        """
        将生成的图像文件压缩成一个zip文件，便于分发和存储。
        """
        dir_to_zip = r"./传热拟合图结果"  # 存放结果的目录
        dir_to_save = r"./传热实验结果.zip"  # 目标zip文件路径

        # 检查结果目录是否存在
        if not os.path.exists(dir_to_zip):
            print(f"警告：结果目录 {dir_to_zip} 不存在，无法压缩")
            return

        # 创建zip文件并将结果目录中的所有文件添加进去
        with zipfile.ZipFile(dir_to_save, "w", zipfile.ZIP_DEFLATED) as zipf:
            for root, dirs, files in os.walk(dir_to_zip):
                for file in files:
                    file_path = os.path.join(root, file)
                    arcname = os.path.relpath(file_path, dir_to_zip)
                    zipf.write(file_path, arcname)

        # 打印压缩完成的确认信息
        print(f"压缩完成。文件已保存为: {dir_to_save}")

    def generate_summary_report(self):
        """
        生成实验数据摘要报告
        """
        report = []
        for data in self.processed_data:
            report.append(
                {
                    "实验类型": data["type"],
                    "数据点数": len(data["data_for_fit"]),
                    "拟合参数A": (data["params"][0] if data["params"] is not None else "N/A"),
                    "拟合参数B": (data["params"][1] if data["params"] is not None else "N/A"),
                }
            )

        report_df = pd.DataFrame(report)
        report_path = "./传热拟合图结果/实验摘要.csv"
        os.makedirs(os.path.dirname(report_path), exist_ok=True)
        report_df.to_csv(report_path, index=False, encoding="utf_8_sig")
        print(f"实验摘要已保存至: {report_path}")


if __name__ == "__main__":
    # 定义CSV文件路径列表
    csv_file_paths = [
        "原始数据-无强化套管.csv",
        "原始数据-有强化套管.csv",
        "数据预处理-无强化套管.csv",
        "数据预处理-有强化套管.csv",
    ]

    # 初始化处理类
    processor = Heat_Transfer_Experiment_Processor(csv_file_paths)

    # 第一步：处理数据（包括计算、拟合等）
    processor.calculate()

    # 第二步：存储处理后的数据（可选步骤，用于生成结果或摘要）
    processor.store()

    # 第三步：基于处理后的数据生成图形
    processor.plot()

    # 第四步：生成实验摘要报告
    processor.generate_summary_report()

    # 第五步：压缩结果图像文件为zip文件
    processor.compress_results()


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\processors\oxygen_desorption_experiment_processor.py 的内容:
================================================================================
# Oxygen_Desorption_Experiment_Processor_processor.py

# 内部库
import sys
import os
from pathlib import Path

# 动态获取项目根路径
current_script_path = os.path.abspath(__file__)
project_root = Path(current_script_path).parents[3]  # parents[3]向上4级到项目根
sys.path.insert(0, str(project_root))

import zipfile
from typing import Optional

from gui.screens.calculators.oxygen_desorption_calculator import (
    Experiment_Data_Loader,
    Packed_Tower_Calculator,
    Oxygen_Desorption_Calculator,
)
from gui.screens.plotters.oxygen_desorption_plotter import Packed_Tower_Plotter, Oxygen_Desorption_Plotter


class ResultCompressor:
    @staticmethod
    def compress_results(output_dir: str = "./拟合图结果", zip_name: str = "拟合图结果.zip"):
        """压缩结果文件

        Args:
            output_dir (str): 结果文件目录
            zip_name (str): 压缩包名称

        Raises:
            FileNotFoundError: 当输出目录不存在时抛出
        """
        output_path = Path(output_dir)
        if not output_path.exists():
            raise FileNotFoundError(f"目录 {output_dir} 不存在")

        with zipfile.ZipFile(zip_name, "w") as zipf:
            for file_path in output_path.rglob("*"):
                if file_path.is_file():
                    arcname = file_path.relative_to(output_path)
                    zipf.write(file_path, arcname)
        print(f"结果已压缩至 {Path(zip_name).absolute()}")


class Oxygen_Desorption_Experiment_Processor:
    def __init__(
        self,
        dry_packed_path: str,
        wet_packed_path: str,
        water_constant_path: str,
        air_constant_path: str,
        output_dir: Optional[str] = None,
    ):
        """初始化实验处理器

        Args:
            dry_packed_path: 干填料数据文件路径
            wet_packed_path: 湿填料数据文件路径
            water_constant_path: 水流量一定数据文件路径
            air_constant_path: 空气流量一定数据文件路径
            output_dir: 输出目录路径，默认为"./拟合图结果"
        """
        # 初始化数据加载器
        self.data_loader = Experiment_Data_Loader(
            dry_packed=dry_packed_path,
            wet_packed=wet_packed_path,
            water_constant=water_constant_path,
            air_constant=air_constant_path,
        )

        # 设置输出目录
        self.output_dir = Path(output_dir) if output_dir else Path("./拟合图结果")
        self.output_dir.mkdir(parents=True, exist_ok=True)

    def run_full_analysis(self, compress_results: bool = True):
        """执行完整分析流程

        Args:
            compress_results: 是否压缩结果文件，默认为True
        """
        try:
            # 填料塔分析
            tower_calculator = Packed_Tower_Calculator(self.data_loader)
            tower_calculator.analyze_all_files()

            tower_plotter = Packed_Tower_Plotter(tower_calculator)
            tower_plotter.plot_comparison(save_path=str(self.output_dir / "填料塔性能对比.png"))

            # 氧解吸分析
            oxygen_calculator = Oxygen_Desorption_Calculator(self.data_loader)
            oxygen_calculator.analyze_all_files()

            oxygen_plotter = Oxygen_Desorption_Plotter(oxygen_calculator)
            oxygen_plotter.plot_correlation(save_path=str(self.output_dir / "氧解吸传质关联.png"))

            # 可选结果压缩
            if compress_results:
                ResultCompressor.compress_results(
                    output_dir=str(self.output_dir), zip_name=str(self.output_dir.parent / "拟合图结果.zip")
                )

        except Exception as e:
            print(f"分析过程中发生错误: {str(e)}")
            raise


if __name__ == "__main__":
    # 使用示例
    try:
        # 替换为实际文件路径
        processor = Oxygen_Desorption_Experiment_Processor(
            dry_packed_path="./csv_data/解吸原始记录表(非)/干填料.csv",
            wet_packed_path="./csv_data/解吸原始记录表(非)/湿填料.csv",
            water_constant_path="./csv_data/解吸原始记录表(非)/水流量一定_空气流量改变.csv",
            air_constant_path="./csv_data/解吸原始记录表(非)/空气流量一定_水流量改变.csv",
        )

        processor.run_full_analysis()

    except Exception as e:
        print(f"程序运行失败: {str(e)}")


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\processors\__init__.py 的内容:
================================================================================


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\utils\config.py 的内容:
================================================================================
# 快捷键对应event.state的数值
SHORTCUT_CODE = {"Shift": 0x1, "Control": 0x4, "Command": 0x8, "Alt": 0x20000}

DATA_CONFIG = {
    "app": None,
    "window": None,
    "screen": None,
    "mode": None,
    "csv_len": -1,
    "csv": None,
    "time_lower_limit": 30,
    "time_upper_limit": 40,
    "std_limit": 0.005,
}

SCREEN_CONFIG = {"borderwidth": 5, "relief": "raised"}

MAIN_FRAME_CONFIG = {"borderwidth": 5, "relief": "sunken"}

RAISED_SUBFRAME_CONFIG = {"borderwidth": 1, "relief": "raised"}

FLAT_SUBFRAME_CONFIG = {"borderwidth": 2}

ENTRY_LABEL_CONFIG = {"padding": 2}

PLOT_CONFIG = {
    "MainScatter": {"s": 5, "color": "dimgray"},
    "MainLine": {"linewidth": 1, "color": "#1F77B4"},
}

DEFAULT_DATA_VALUE = {
    # 其他默认值
}


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\utils\expserial.py 的内容:
================================================================================
# gui/utils/expserial.py

# Author: 安孝彦
# 内置库
import time

# 第三方库
from func_timeout import func_set_timeout
from serial import Serial, SerialException
from serial.serialutil import PortNotOpenError
from serial.tools import list_ports

# 有如下几种报错
# 找不到端口 SerialException FileNotFoundError
# 已经打开的端口重复打开 SerialException Port is already open (但重复关闭不会有问题)
# 端口被占用 SerialException PermissionError
# 使用未打开端口 serialutil.PortNotOpenError
# 突然断开连接 SerialException GetOverlappedResult（关机没问题，只有拔线有问题）
# 断开后重新插回 SerialException ClearCommError （好像只有重新连接一种解决方法）

# 启动时会有一段FF 80 0A/0B 0D 0E 0A 0A的数据，注意处理。

COMPORTS = []  # 存储端口信息
port_status = False  # 初始化端口状态


# 获取可用端口信息
def getComPorts(select=False, timeout: float = 0.25):
    global COMPORTS, port_status

    # 使用装饰器设置超时时间
    @func_set_timeout(timeout)  # 设置超时时间为0.25s
    def detectComPort(port_name):
        global port_status
        try:
            with Serial(port_name, 1200, timeout=1) as ser:  # 打开信息为port_name的端口，波特率1200，超时1s
                port_read = ser.read(7)
                if len(port_read) < 7:  # 如果读取的数据长度小于7，说明没有数据传入
                    return  # 跳过本次循环
                else:
                    port_status = True
                    return
        except Exception:  # 如果出现异常
            return  # 跳过本次循环

    # 检测端口是否可用
    COMPORTS = []  # 清空端口信息
    all_ports = list_ports.comports()  # 获取所有端口信息
    for port_info in all_ports:
        port_status = False  # 默认当前检测的端口不可用
        port_name = str(port_info.device)  # 遍历获取端口信息
        if select:
            try:
                detectComPort(port_name)  # 检测端口是否可用
            except:
                pass
        if port_status:
            COMPORTS.append(port_name)
    return sorted(COMPORTS, key=lambda x: x[3:])  # 返回端口信息


# 计算温差
def derive_Delta_T(msg):
    dT = msg[3] + (msg[4] + (msg[5] + msg[6] / 10) / 10) / 10
    if msg[2] == 10:
        pass
    elif msg[2] == 11:
        dT = -dT
    elif msg[2] == 1:
        dT += 10
    elif msg[2] == 12:
        dT = -10 - dT
    return dT


class EasySerial:
    """
    将serial的Serial打包成在本实验中更易使用的结构
    """

    def __init__(self, name, baud=1200):  # 除非更换设备，否则此处波特率1200不要改
        self._name = name  # 端口名
        self._baud = baud  # 波特率
        self._port = None  # 未打开端口
        self._changed = False  # 端口名改变标志位，初始为False，改变后为True

    # 设置要打开的端口
    def setName(self, name):
        self._name = name
        self._changed = True

    # 打开端口
    def open(self):
        self.close()  # 先关闭可能打开的端口
        if self._changed or self._port is None:  # 如果端口名改变或端口未打开
            try:
                self._port = Serial(self._name, self._baud)  # 打开端口
                self._changed = False  # 端口名改变标志位清零
            except SerialException as e:
                self._port = None  # 未打开端口
                s = str(e)
                if "PermissionError" in s:  # 最可能是多开造成的
                    raise PermissionError("端口被占用！请查找可能占用端口的程序！")
                elif "FileNotFoundError" in s:
                    raise FileNotFoundError("未知端口名！请检查线缆是否正确连接！")
                else:
                    raise e
        if self._port is not None and not self._port.is_open:  # 如果端口应打开但打开失败
            # 解决了串口断线重连的问题
            try:
                self._port.open()  # 重新尝试打开端口
                time.sleep(0.5)  # 等待0.5s
            except SerialException as e:
                pass

    # 读取温度
    @func_set_timeout(1)
    def read(self):
        if self._port is None:
            "端口未打开！请先打开端口！"
            return
        elif not self._port.is_open:
            try:
                self._port.open()
            except SerialException as e:
                return
        msg = b""
        try:
            self._port.read_all()  #!! 清空缓存
            while self._port.in_waiting < 7:  # 等待7个字节
                pass
            msg = self._port.read(7)  # 读取7个字节
            while len(msg) < 7 or msg.find(b"\xff") < 0:  # 如果读取的数据长度小于7或没有找到FF
                msg = self._port.read(7)  # 读取7个字节
            i = msg.find(b"\xff")  # 找到第一个FF的位置，作为起始位置
            msg = msg[i:] + self._port.read(i)  # 一个完整的数据由FF开头，并有7个字节，根据FF的位置补全数据
            while msg[-1] == 10:  # 如果最后一个字节为0A，即启动时出现的非温差数据
                msg = self._port.read(7)  # 再读取7个字节
            temperature = derive_Delta_T(msg)  # 计算温差
            return temperature  # 返回温差
        except AssertionError as e:
            print(msg)
            raise e
        except AttributeError as e:
            if "NoneType" in s:
                raise ValueError("端口未打开！请先打开端口！")
            else:
                raise e
        except PortNotOpenError:
            raise ValueError("端口未打开！请先打开端口！")
        except SerialException as e:
            s = str(e)
            if "GetOverlappedResult" in s:
                raise BufferError("连接已断开！请检查物理线缆连接！")
            elif "ClearCommError" in s:
                raise IOError("状态错误！请断开重连！")
            else:
                raise e

    # 关闭端口
    def close(self):
        if self._port is not None:
            self._port.close()  # 调用serial的close方法关闭端口


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\utils\__init__.py 的内容:
================================================================================


================================================================================
E:\Chem-Experiment-Process-App\gui\screens\widgets\__init__.py 的内容:
================================================================================


